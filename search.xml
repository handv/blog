<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【翻译】我是一个平庸的程序员]]></title>
    <url>%2F%2Fblog%2F2019%2F02%2FI_am_a_mediocre_developer.html</url>
    <content type="text"><![CDATA[我个人认为有一些程序员就是天才，他们可以轻而易举地创造一些了不起的软件产品。因为这群天才的存在，我们对这个行业充满了期待。但是有一个悲伤的事实是：不是每一个人都是大师级的程序员。 实际上这就是我，一个平庸的程序员。这篇文章将指导你，作为一个非天才程序员，如何在这个行业中生存。 我一直用google搜索最简单的技术我记不住很多东西。比如，标准库里的函数和方法，参数的位置，依赖的包名，样板代码等等。 所以，我需要用google搜索。而且，我每天如此。而且，我也从旧的项目里复用代码，有时也从StackOverflow或者GitHub上复制别人的代码。是的，我是一个面向StackOverflow编程的程序员。 但我不是一个人在战斗，很多很多程序员都像我一样。Ruby on Rails的作者曾经发过一个很火的twitter。 这样子写代码有什么不好呢？有如下几点坏处： 你可能从别人那拷贝的，是糟糕的设计或者很烂的代码。 容易形成一个坏的心态：如果不能从网上搜索到你想到的，那么就是“休斯顿，我们遇到麻烦了”。 如果没有网了，那么你就无法工作了。 但是，我并不认为这是一个大问题。它甚至可以作为你的秘密武器。我有几点建议减轻这些负面影响。 生存法则1 使用IDE的代码自动补全和提示，你就不用去搜索语言的基础用法了。 记住你在什么地方或使用什么方法解决了这个问题。下一次遇到同样的问题，找出来看一下就可以了。 你提交到项目中的所有代码，都应该在之后进行分析、重构和评审。这样做，就不会用糟糕的代码降低项目的质量，而是帮助它获得快速的解决方案。 保存事情的简单性我们说什么，机器做什么。有时候，机器做了错误的事情，仅仅是因为我们下了错误的指令。因此软件开发中的主要问题，不是机器，而是开发人员的思维能力。这种能力是有限的。所以，我们作为一个平庸的程序员，不要浪费脑子去创建复杂的抽象设计、编写晦涩的算法或不可读的长代码块。保持简单性。 然而，我们怎么区分这段代码是简单的还是复杂的？我们需要使用WTFs/分钟的方法去衡量代码质量。（译者注：WTF = What the Fu**） 这条规则非常简单易懂。你发现代码中有一些你看不懂的东西，那它就是复杂的。你应该怎么做？ 重写代码，让人看起来清晰 提供文档 在最难懂的地方添加注释。但是记住，过多的注释本身，就是代码的坏味道。（译者注：参见22种代码味道） 生存法则2(怎样开始编写简单的东西) 使用正确的变量名、函数名和类名 确保你代码每一部分只做一件事件 优先使用纯函数，而不是常规函数 优先使用常规函数，而不是类 只在非常必要的情况下，才使用回调 我不相信我自己一些开发者已经证明他们能提交高质量的代码。像下面这位女神：Margaret Hamilton，阿波罗计划的首席软件工程师。这张图里，她旁边的等身高的纸，就是为登月任务编写的代码。 不过，但于我而言，无论我编写任何代码，我不相信我自己。即使是做项目里最简单的部分，我也能把事件搞得非常糟糕，可能包括： 语言错误 逻辑错误 设计错误 演示错误 安全性错误 WTF错误（我最喜欢的） 世界上并没有一本关于“如何编写无bug代码”的魔法师，所以这些错误都是正常的。所有的软件都有bug，处理掉它就是了。 实际上，任何人都不允许编写带有明显错误的代码。所以至少我们应该尝试做到这一点。我应该怎样保护我自己的项目呢？下面有几条建议。 生存法则3 编写测试用例，编写大量的测试用例。大到集成测试，小到单元测试。在每次拉取请求前执行CI持续集成，这将减少你的一些逻辑错误。 使用静态数据类型或者可选静态类型。例如，我们在python中使用mypy，在javascript中使用flow（译者注：现在应该使用Typescript）。这样做的好处是：清晰的设计和编译时类型检查。 使用自动样式检测工具。每种语言都有大量的样式检查工具。 使用质量检测工具。有些工具在你的代码库上运行一些复杂的启发式算法来检测不同的问题，比如这行内部逻辑太多，不需要这个类，这个函数太复杂。 检阅你的代码。在合并到主分支之前代码，有时候在合并之后也需要review。 花钱让别人审核你的代码。这样做有相当大的好处，因为当别的程序员第一次看你的代码时，很容易看出不一致的地方和糟糕的代码设计。 不应该只在我的电脑上有效 差不多十年前，当我的团队开发完第一个大型软件项目时，我们将其作为java源文件发布。在我们呈现给客户前的几个小时，它在目标服务器上编译失败了。这算是个大事故。虽然最终我们修复好了并运行起来，但这是个终身难忘的经历。 这是因为在构建管道里，有着大量的配置和大量的复杂性。我们没有能力去正确管理该系统的复杂性。从那天开始，为了减少这一步的复杂性，我尝试将程序打包在独立的环境中，并在实际部署之前在此环境中进行测试。 这几年，随着docker（以及一般的容器）的兴起，这件事情开始变得简单起来。docker允许你在完全相同的独立环境下进行开发、测试和生产上线。采用这种方式，你不会遗留任何重要的事情。 不好吗？说说我自己，在搭建服务、初始化配置或者链接一些东西的时候，我总会遗漏掉一部分。因为有许多东西需要记住。幸运的是，我们仍然可以实现自动化。有许多很棒的工具可以进行自动化部署。如：terraform, ansible, and packer。查看他们的文档，找到适合你的工具。 我也尝试设置CI/CD进行持续集成和持续部署。当在测试和部署的自动化构建失败时，我会收到报告通知。 生存法则4 一切使用自动化部署 使用docker作为开发、测试和生产环境 使用部署工具 在部署应用后，我仍然不相信我自己最后，我的应用已经在生产环境上线了，它已经在运行了。我可以打个小盹儿了，什么事儿都不会发生。等一下，不，一切都将崩溃。是的，一切。 实际上，有一些工具可以很容易的发现和修复现在问题。 Sentry. 任何一个你的用户产生异常时，你都会收到通知。Sentry已经支持几乎所有的开发语言。 各式各样的服务和工具，可以将多个程序的日志收集到一个地方。 服务监控.你可以对CPU、硬盘、网络和存储器配置监控。你甚至可以在用户实际压垮你的服务之前，确定需要进行服务扩容的时间。 简单来说，我们需要在生产环境上进行监控。有的时候你需要上述所有工具，有的时候你只需要一部分。要根据自己的情况进行判断。 持续学习哇，有好多需要学的东西。但这就是我的生存方式。如果我们想写好代码，我们就需要持续学习。成功路上没有捷径，你需要做的就是学习如何一天比一天好。 总结来说，我们需要理解两个基本原则： 每个人都会遇到问题。最关键的是，我们对这些问题，准备好了吗，准备到什么程度。 我们可以把问题的根源降低到可接受的程度。 这与你的思维能力或心态无关。 关于本文作者：@Nikita Sobolev原文：https://dev.to/sobolevn/i-am-a-mediocre-developer--30hn]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas图片如何旋转90度]]></title>
    <url>%2F%2Fblog%2F2019%2F01%2Fcanvas%E5%9B%BE%E7%89%87%E6%97%8B%E8%BD%AC%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[canvas如何实现将一张图片旋转90度的效果呢？ 方法1：修改canvas的css，将canvas旋转90度index.html123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; body &#123; margin: 0px; padding: 0px; &#125; canvas &#123; border: 1px solid red; margin-bottom: 150px; display: block; &#125; #myCanvas2 &#123; transform: rotate(90deg); &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id="myCanvas"&gt;&lt;/canvas&gt; &lt;canvas id="myCanvas2"&gt;&lt;/canvas&gt; &lt;script&gt; var canvas = document.getElementById('myCanvas') var context = canvas.getContext('2d') var canvas2 = document.getElementById('myCanvas2') var context2 = canvas2.getContext('2d') var imageObj = new Image() imageObj.width = 440 imageObj.height = 302 var width = imageObj.width var height = imageObj.height imageObj.onload = function() &#123; canvas.width = width canvas.height = height canvas2.width = width canvas2.height = height context.drawImage(imageObj, 0, 0) context2.drawImage(imageObj, 0, 0) &#125; imageObj.src = 'https://www.html5canvastutorials.com/demos/assets/darth-vader.jpg' &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 缺点： 仅仅是从视觉上将图片旋转了，但如果将图片导出，获取到canvas2.toDataURL(‘image/png’)，图片仍然是正常的，而不是旋转之后的。 方法2：canvas不变，将图片旋转90度12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; body &#123; margin: 0px; padding: 0px; &#125; canvas &#123; border: 1px solid red; margin-bottom: 50px; display: block; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id="myCanvas"&gt;&lt;/canvas&gt; &lt;canvas id="myCanvas2"&gt;&lt;/canvas&gt; &lt;script&gt; var canvas = document.getElementById('myCanvas') var context = canvas.getContext('2d') var canvas2 = document.getElementById('myCanvas2') var context2 = canvas2.getContext('2d') var imageObj = new Image() imageObj.src = 'https://www.html5canvastutorials.com/demos/assets/darth-vader.jpg' imageObj.width = 440 imageObj.height = 300 var width = imageObj.width var height = imageObj.height imageObj.onload = function() &#123; canvas.width = width canvas.height = height canvas2.width = height canvas2.height = width context.drawImage(imageObj, 0, 0) context2.translate(canvas2.width / 2, canvas2.height / 2) context2.rotate(Math.PI * 90 / 180) context2.drawImage(imageObj, -canvas2.height / 2, -canvas2.width / 2) context2.rotate(-Math.PI / 2) context2.translate(-canvas2.width / 2, -canvas2.height / 2) &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; canvas api translate(): 重新映射画布上的 (0,0) 位置 rotate(): 方法旋转当前的绘图 要想理解这两个用法，就需要清楚转换之后的坐标位置，参考这篇文章 原理 先将ctx坐标移至canvas中心 旋转ctx90度，改变坐标系位置 将图片在坐标系的负1/2处渲染出来 将ctx坐标恢复默认 注意:图片在canvas中的渲染，一定要放到imageObj.onload中，否则可能会出现渲染出来的图片为空，因为imageObj尚未加载完成。 掌握了这个旋转方法，在literallycanvas中的图片旋转就变得很简单了 参考我的代码]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>Canvas</tag>
        <tag>Literallycanvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018前端年终盘点]]></title>
    <url>%2F%2Fblog%2F2019%2F01%2F2018%E5%89%8D%E7%AB%AF%E5%B9%B4%E7%BB%88%E7%9B%98%E7%82%B9.html</url>
    <content type="text"><![CDATA[年度盘点系列 前端 2018 解读 2018年GitHub年度盘点（中文链接） 2018年JavaScript生态圈调查报告出炉！（中文链接） New ES2018 Features Every JavaScript Developer Should Know (中文链接) 剩余参数和扩展运算符 异步迭代 Promise.finally 正则表达式 标记模板文字 The Most Liked CodePen Examples in 2018 知识点 Node.js和JavaScript测试最佳实践 redux作者Dan Abramov不知道的事 1234567不管你的程度多好，你仍会感到不安或毫无自信。虽然经验丰富的开发者也有很多不会的东西，但他们仍拥有十分宝贵的专业与技术。我知道我的知识缺口是哪些（至少是某些）。我可以在未来我感到好奇或需要它们的时候补强这些不足。而这个认知并不会抹煞我的知识与经验。有很多事情是我可以做得很好的。例如：在我需要某个技术的时候，把它学起来。 如何用svg画一个进度环]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重构一时爽...]]></title>
    <url>%2F%2Fblog%2F2019%2F01%2F%E9%87%8D%E6%9E%84%E4%B8%80%E6%97%B6%E7%88%BD.html</url>
    <content type="text"><![CDATA[俗话说的好，“重构一时爽，全家火葬场”。这两天就遇到了这么个事。 本来一个老项目要加一点新需求，挺简单的事，前端一两天就干完了。偏偏遇到了后端大佬把接口重构了，接口名、请求参数、请求方式、返回数据都有变化，这可就有的忙了，光重构就重构了好久。 要说光改改接口，返回结果格式，也问题不大，稍微麻烦一点吧，多弄两天也就ok了。偏偏遇到自己这时候强迫症犯了，把之前项目写的不好的地方又重新整了一遍。原先的项目路由一直设置的不好（前人历史遗留问题），参数全部用的search格式，导致每次数据变化了都要用componentWillReceiveProps来进行判断，不仅判断起来复杂，还会导致render执行多次，造成浪费，而且debug起来也很麻烦。索性改了，引发关键数据变化的参数统统改成router pathname，这样子数据变化的时候只需要判断componentDidMount或者componentDidUpdate就可以了。 这样子就相当于将整个项目都重写了一遍，又花了大几天的时间。如果到这了，也就ok。偏偏让我看到了antd的版本还停留在2.x时代，这antd都已经更新到3.11.6（重构项目的时候，刚才我又看了一眼antd的更新日志，已经到3.12了。）怎么办，升级呗，升完了感觉确实好看一点点了。 到这里感觉应该差不多了吧，嗯。。。，这个ui界面长得还是丑了点。纯粹是产品画了张草图，开发自己随便方便着来的布局，没有一点点的美感。虽说这是个内部系统，可以也太不好看了吧。用antd-pro重写一遍？杀了我吧，实在是改不动了。 虽然不能用antd-pro来重写，但antd-pro的页面布局可以考虑一下啊，找demo里合适的布局样式来改了改。嗯，改完了还挺好看的，终于有点高大上的感觉了。完结撒花！！！ 有人要问了，你这么搞不是多花了好多的工作时间，导致项目周期延长吗？错了，这也是为啥说重构一时爽的原因了。在不影响项目周期的前提下，进行自我认同的重构工作，都是在下班时间搞的。就像现在这个，元旦假期搞了好几天呢，甚至还通了个宵，隐隐的感觉到了身体被掏空。。。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo next主题配置]]></title>
    <url>%2F%2Fblog%2F2018%2F12%2Fhexo-next%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[站在巨人的肩膀上，提供一下链接： next官方文档 搭建hexo 百度统计配置 阅读人数配置 字数统计、阅读时长配置 工具 来必力评论系统 百度统计 leancloud阅读人数统计]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年终总结]]></title>
    <url>%2F%2Fblog%2F2018%2F12%2F2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[2018年就要过去了，已经迈进而立之年的我，也来总结一下自己的这一年，这一年是收获良多的一年。 收获年糕一枚2018年初，成功升级当了爸爸。从进产房起到生孩子，我都贴身陪同媳妇儿。经历了这一切的人，都会感受到母亲的伟大，忍受住那么大的痛苦，才能得到生命的传承。一个心甘情愿为你生孩子的女人，有什么理由不宠着爱着她一辈子。 这一年，也见证着小宝宝的成长。那么小那么脆弱的小生命，只能轻轻的抱着他，怕不小心弄伤他。从抱孩子的姿势，到换尿布，喂奶粉，晚上不睡觉陪着他，养儿方知父母恩，只有有了自己的孩子，你才能体会到什么叫无私的爱，无私的奉献。 一个月，两个月，三个月。。。转眼年糕就要一岁了。这一年，见证了他的抬头，翻身，会坐，会爬，会站，马上就要会走了。同时也经历了他感冒发烧咳嗽拉肚子，一次又一次的跑医院，还好你平安健康。从一个小不点长到现在会调皮捣蛋。爸爸和妈妈会一直一起陪着你长大。 感谢老婆大人的付出，她真的是很辛苦。白天要那么早去挤地铁，晚上回来还睡不了整觉，半夜还得起来喂奶。从怀孕开始，就没怎么休过假，一直在忙带孩子，忙工作。明年争取两个人去度个小假，让你放松放松。 同时也要感谢爸爸妈妈岳父岳母，这四位老人无私的帮着带孩子。周末我和媳妇带他一天就累得够呛，平时都是爸妈帮着看，真的是辛苦他们了。 生活上要对明年充满希望，对自己和家人都要负责，所以立贴为证吧。2019我要做到： 减肥 每周三次健身房，跑步一次 每天中午吃完饭溜达一圈 每顿吃八分饱，不喝可乐，不吃垃圾食品 尽量少熬夜 读书 工业4.0 系统论 薄荷阅读 计划 跟老婆二人世界小假期一次 听一场宫崎骏音乐会 升职加薪 买保险 又累又幸福的工作转岗前端已经一年多了。一年前的今天，我还刚刚调好了登录的跨域，离上线还有着很长的距离。这一年真的是收获颇丰，涨了很多的实战经验，更多的发现了自己的不足。感谢我的领导，是个体恤下级的好领导，会为你的发展着想，给你发挥的余地。跟身边这帮聪明的同事比起来，我要学习的地方还是很多。 新的一年，我希望有更加长足的进步，更加全方面的发展自己的技能，而且并不局限于技术这一点。所以，立几个flag吧： react 学完极客时间教程 学完慕课网教程 搞懂redux-saga，dva 写一个关于antd-pro的ppt 深入理解react原理 掌握前端设计模式 前端基础 慕课网前端基础 es6特性 event loop、同步异步、generator 闭包、作用域、原型 css特性 其他 算法，刷题scriptoj 图解http 把这个博客的功能搞全了 每周坚持一篇博客，不管是原创还是翻译，希望坚持下去。 2018转眼过去了，2019年希望自己和家人身体健康，工作顺利！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux-thunk的原理解析]]></title>
    <url>%2F%2Fblog%2F2018%2F11%2Fredux-thunk%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"><![CDATA[参考文档：redux-thunk的原理解析 个人理解：1、首先了解redux的中间件原理const store = createStore(reducer, applyMiddleware(thunk))在createStore的时候，如果应用了中间件，那么store的属性dispatch、getState可能会被重写而在redux-thunk中，dispatch就被重写了2、redux-thunk 1234567891011121314function createThunkMiddleware(extraArgument) &#123; return (&#123; dispatch, getState &#125;) =&gt; next =&gt; action =&gt; &#123; if (typeof action === 'function') &#123; return action(dispatch, getState, extraArgument); &#125; return next(action); &#125;;&#125;const thunk = createThunkMiddleware();thunk.withExtraArgument = createThunkMiddleware;export default thunk; 应用了redux-thunk后，dispatch变成了一个可以传function参数的dispatch，当遇到action为function时，执行该function的action，如果是正常的action，则执行dispatch 12345678dispatch=function(store.dispatch)&#123; action =&gt; &#123; if (typeof action === 'function') &#123; return action(store.dispatch, getState, extraArgument); &#125; return store.dispatch(action); &#125;; &#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux-thunk</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科里化]]></title>
    <url>%2F%2Fblog%2F2018%2F11%2F%E7%A7%91%E9%87%8C%E5%8C%96.html</url>
    <content type="text"><![CDATA[bind的概念 12var result = fun.bind(thisArg[, arg1[, arg2[, ...]]]) result(newArg1, newArg2...) bind返回一个新的函数，这个函数要绑定的this对象指向第一个参数，后面的参数是传入新函数的参数。这个函数的功能和fun函数的功能一样。所以，上面的bind函数可以等价于：1result(newArg1, newArg2...) = thisArg.fun(newArg1, newArg2...) 科里化的概念 1）科里化的目的123把func(arg1, arg2, arg3...)类型的函数转换成func(arg1)(arg2)(arg3)(...)类型 2）科里化的返回值 所以科里化的返回值仍然是一个函数，这样才能继续执行后面的参数(arg2)(arg3)(…) 3）科里化的定义 将函数与其参数的一个子集绑定起来后返回个新函数。 所以要绑定，就需要bind方法 4）科里化的实现1234567var currying = function(fn) &#123; var args = [].slice.call(arguments, 1); return function() &#123; var newArgs = args.concat([].slice.call(arguments)); return fn.apply(null, newArgs); &#125;;&#125;;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>curry</tag>
        <tag>js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React单元测试实战]]></title>
    <url>%2F%2Fblog%2F2018%2F10%2FReact%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%AE%9E%E6%88%98.html</url>
    <content type="text"><![CDATA[目录 什么是单元测试 Jest &amp;&amp; Enzyme 测试实战 总结 什么是单元测试单元测试 维基百科 在计算机编程中，单元测试（英语：Unit Testing）又称为模块测试, 是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。通常来说，程序员每修改一次程序就会进行最少一次单元测试，在编写程序的过程中前后很可能要进行多次单元测试，以证实程序达到软件规格书要求的工作目标，没有程序错误；虽然单元测试不是什么必须的，但也不坏，这牵涉到项目管理的政策决定。每个理想的测试案例独立于其它案例；为测试时隔离模块，经常使用stubs、mock或fake等测试马甲程序。单元测试通常由软件开发人员编写，用于确保他们所写的代码匹配软件需求和遵循开发目标。它的实施方式可以是非常手动的（透过纸笔），或者是做成构建自动化的一部分。 一个软件越容易写单元测试，就表明它的模块化结构越好，模块之间的耦合越弱。React的组件化和函数式编程，天生适合进行单元测试。 为什么要写单元测试 测试可以确保得到预期的结果，改代码更自信 有单元测试的代码，通常是更好的代码 写单元测试的时候，会更深入的认识代码； 为了更方便的写单元测试，组件拆分更合理。 所有代码变动都是可预期的 更好的提升自我 写单测的开发更靠谱 更好的吹牛逼（我的单元测试覆盖率是100%） 评级加分 单元测试不是万能的 单元测试只是测试代码功能，不包含复杂的业务逻辑。 Jest &amp;&amp; EnzymeJestJest是Facebook发布的一个开源的、基于Jasmine框架的JavaScript单元测试工具。提供了包括内置的测试环境DOM API支持、断言库、Mock库等，还包含了Spapshot Testing、 Instant Feedback等特性。用来测试包括React应用在内的所有JavaScript代码。 优点 提供控制台实时反馈测试结果 提供内置的测试环境DOM API支持、断言库、Mock库、代码覆盖率报告 Snapshot测试：Jest能够对React组件树进行序列化，生成对应的字符串快照，通过比较字符串提供高性能的UI检测 执行速度快 无需配置 使用 create-react-app 或 react-native init 创建你的 React 或 React Native 项目时，Jest 都已经被配置好并可以使用了。在 tests文件夹下放置你的测试用例，或者使用 .spec.js 或 .test.js 后缀给它们命名。不管你选哪一种方式，Jest 都能找到并且运行它们。 丰富的api，完善的文档 在线使用 可以使用repl.it来在线尝试Jest。想想怎么用add ()函数来相加两个数。我们可以编写一个简单的测试，通过 add-test.js来验证 1 + 2 等于 3。输入”run”立马尝试。 EnzymeEnzyme是Airbnb开源的React测试类库，提供了一套简洁强大的API，并通过jquery风格的方式进行dom处理，开发体验十分友好。不仅在开源社区有超高人气，同时也获得了React官方的推荐。 为啥除了Enzyme又要配合Jest呢？ 因为要编写测试用例的话，光有测试类库还不够，还需要测试运行环境、断言库、mock库等等工具辅以支持；Jest把这些统统囊括。 测试环境搭建以create-react-app为例 1npm install --save enzyme enzyme-adapter-react-16 enzyme-to-json react-test-renderer 如果React的版本是15或者16, Enzyme需要一个Adapter与React通信。adapter需要全局配置，方法如下: 12345src/setupTests.jsimport &#123; configure &#125; from 'enzyme'import Adapter from 'enzyme-adapter-react-16'configure(&#123; adapter: new Adapter() &#125;) 常用api介绍Enzyme api shallow渲染 shallow: 返回App的浅渲染 浅渲染指的是，将一个组件渲染成虚拟DOM对象，但是只渲染第一层，不渲染所有子组件，所以处理速度非常快。它不需要DOM环境，因为根本没有加载进DOM。 find(selector): 返回指定ShallowWrapper组件 123456789component.find('.my-class'); // by class namecomponent.find('#my-id'); // by idcomponent.find('td'); // by tagcomponent.find('div.custom-class'); // by compound selectorcomponent.find('[bar=false]'); // by prop selectorcomponent.find(TableRow); // by react component constructorcomponent.find('TableRow'); // by react component's displayname at(index): 返回指定位置的子组件 get(index): 返回指定位置的子组件的DOM节点 props(): 返回根组件的所有属性 prop(key): 返回根组件的指定属性 state([key]): 返回根组件的状态 setState(nextState): 设置根组件的状态 setProps(nextProps): 设置根组件的属性 simulate(event[, …args]): 模拟事件 debug() 1console.log(wrapper.find('Ueditor').debug()) 它跟shallow方法非常像，主要的不同是采用了第三方HTML解析库Cheerio，它返回的是一个Cheerio实例对象。 render渲染 render: 将React组件渲染成静态的HTML字符串，然后使用Cheerio这个库分析这段HTML代码的结构，返回一个Cheerio对象。 mount渲染 mount: 完全渲染 将React组件加载为真实DOM节点，用到了jsdom来模拟浏览器环境。用于测试： - 需要跟dom api交互的组件 - 被高阶组件包装的组件 Jest api globals api describe(name, fn)：描述块，讲一组功能相关的测试用例组合在一起，test suite it(name, fn, timeout)：别名test，用来放测试用例，test case afterAll(fn, timeout)：所有测试用例跑完以后执行的方法 beforeAll(fn, timeout)：所有测试用例执行之前执行的方法 afterEach(fn)：在每个测试用例执行完后执行的方法 beforeEach(fn)：在每个测试用例执行之前需要执行的方法 expect api expect.toMatchSnapshot() expect.toBeCalledWith(arg1, arg2, …) expect.toEqual(value) expect.toBe(value)，相当于=== mock api jest.fn(): mock function jest.fn().mockResolvedValue(value): 异步mock promise的resolve jest.fn().mockRejectedValue(new Error(‘Async error’)): 异步mock promise的reject Jest命令行 运行所有测试(默认) 1jest or 1npm test 运行监视模式 12npm test --watch // 默认运行基于 hg/git (未提交的文件) 修改的文件的测试npm test --watchAll 生成测试覆盖率报告 1npm test --coverage 测试脚本编写1234567891011import React from 'react'import &#123;shallow&#125; from 'enzyme'import toJson from 'enzyme-to-json'import App from './App'describe('App', () =&gt; &#123; // test suite it('test default props', () =&gt; &#123; // test case const wrapper = shallow(&lt;App /&gt;) expect(toJson(wrapper)).toMatchSnapshot() &#125;)&#125;) snapshot引入’enzyme-to-json’，使用toJson方法，快照会生成一个组件的UI结构。jest在执行的时候，如果发现toMatchSnapshot方法，会在同级目录下生成一个snapshots文件夹,以字符串的形式存放快照文件。 以后每次测试的时候都会和第一次生成的快照进行字符串比较来判断UI是否改变。因为是字符串比较，所以性能很高。 1234567891011121314151617181920212223242526272829303132// 上文中代码生成的snapshotexports[`App test default props 1`] = `&lt;div className="App"&gt; &lt;header className="App-header" &gt; &lt;img alt="logo" className="App-logo" src="logo.svg" /&gt; &lt;p&gt; Edit &lt;code&gt; src/App.js &lt;/code&gt; and save to reload. &lt;/p&gt; &lt;a className="App-link" href="https://reactjs.org" rel="noopener noreferrer" target="_blank" &gt; Learn React &lt;/a&gt; &lt;/header&gt;&lt;/div&gt;`; 当两次快照内容不同时，可以手动修复问题解决。如果是你期望的改动，则可以直接使jest –updateSnapshot来更新快照文件。也可以在监视模式下直接按’u’来更新快照。 优点 不用写大量的断言判断ui，自动生成 异常时给出详细的错误信息，方便调试 一键更新，无需重写测试用例 万物皆可snapshot snapshot不是万能的 snapshot不能覆盖100% snapshot不能替代其他单元测试方法 测试实战what:测什么 测试优先级 独立不依赖，常用组件 辅助性组件，utils 更复杂组件 不需要测试 第三方库 常量 内联样式(不会改变组件的行为) 高阶组件(HOC) how:怎么测示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Choice extends PureComponent &#123; renderType = (type, index) =&gt; &#123; const &#123; answer &#125; = this.props const value = String.fromCharCode(index + 65) switch (type) &#123; case 'checkbox': return ( &lt;Checkbox value=&#123;value&#125; checked=&#123;answer &amp;&amp; answer.includes(value)&#125; &gt; 选项&#123;value&#125;： &lt;/Checkbox&gt; ) case 'radio': return &lt;Radio value=&#123;value&#125; checked=&#123;value === answer&#125;&gt;选项&#123;value&#125;：&lt;/Radio&gt; default: return `选项$&#123;value&#125;：` &#125; &#125; render() &#123; const &#123; choice, index, type, onChange, onClick, parentIndex &#125; = this.props return ( &lt;div className=&#123;s.choice&#125; &gt; &lt;header&gt; &#123; this.renderType(type, index) &#125; &lt;/header&gt; &lt;Row type="flex" justify="start"&gt; &lt;Col&gt; &lt;Button icon="delete" onClick=&#123;() =&gt; onClick(index, parentIndex)&#125; /&gt; &lt;/Col&gt; &lt;/Row&gt; &lt;/div&gt; ) &#125;&#125;Choice.propTypes = &#123; choice: PropTypes.string.isRequired, index: PropTypes.number.isRequired, onChange: PropTypes.func.isRequired, onClick: PropTypes.func.isRequired, answer: PropTypes.string, type: PropTypes.string, parentIndex: PropTypes.number, &#125;Choice.defaultProps = &#123; type: 'text', answer: '', parentIndex: null,&#125;export default Choice ui测试 snapshot测试 prop测试 带prop参数的snapshot测试 123456789101112131415161718192021222324252627282930313233343536373839it('default props', () =&gt; &#123; const wrapper = shallow( &lt;Choice choice="A" index=&#123;0&#125; onChange=&#123;() =&gt; null&#125; onClick=&#123;() =&gt; null&#125; /&gt; ) expect(toJson(wrapper)).toMatchSnapshot()&#125;)it('test props type=radio', () =&gt; &#123; const wrapper = shallow( &lt;Choice choice="A" index=&#123;0&#125; onChange=&#123;() =&gt; null&#125; onClick=&#123;() =&gt; null&#125; type="radio" answer="A" /&gt; ) expect(toJson(wrapper)).toMatchSnapshot()&#125;)it('test props type=checkbox', () =&gt; &#123; const wrapper = shallow( &lt;Choice choice="A" index=&#123;0&#125; onChange=&#123;() =&gt; null&#125; onClick=&#123;() =&gt; null&#125; type="checkbox" answer="AB" /&gt; ) expect(toJson(wrapper)).toMatchSnapshot()&#125;) event测试 对于事件，按照如下思路测试： 123mock event =&gt; simulate it =&gt; expect event was calledmock event =&gt; simulate event with params =&gt; expect event was called with passed paramspass necessary props =&gt; render component =&gt; simulate event =&gt; expect a certain behavior on called event 比如： 123456789101112131415161718it('test function onClick', () =&gt; &#123; const choice = 'C' const index = 2 const parentIndex = 0 const onClick = jest.fn() const wrapper = shallow( &lt;Choice choice=&#123;choice&#125; index=&#123;index&#125; parentIndex=&#123;parentIndex&#125; onChange=&#123;() =&gt; null&#125; onClick=&#123;onClick&#125; answer="A" /&gt; ) wrapper.find('Button').at(0).simulate('click', index, parentIndex) expect(onClick).toBeCalledWith(index, parentIndex)&#125;) 如果事件中有event参数，比如: 123456789handleDifficulty(e) &#123; this.handleChange(&#123; difficulty: e.target.value &#125;)&#125;// 单测中要用&#123; target: &#123; value &#125; &#125;it('test function handleDifficulty', () =&gt; &#123; const value = 1 wrapper.find('RadioGroup').at(0).simulate('change', &#123; target: &#123; value &#125; &#125;) expect(onChange).toBeCalledWith(&#123; difficulty: value &#125;)&#125;) ==备注：对于组件自定义事件，尽量以onXXX命名，才能在simulate的时候触发== state测试 123456789101112131415161718it('test function onClick', () =&gt; &#123; const choice = 'C' const index = 2 const parentIndex = 0 const onClick = jest.fn() const wrapper = shallow( &lt;Choice choice=&#123;choice&#125; index=&#123;index&#125; parentIndex=&#123;parentIndex&#125; onChange=&#123;() =&gt; null&#125; onClick=&#123;onClick&#125; answer="A" /&gt; ) wrapper.find('Button').at(0).simulate('click', index, parentIndex) expect(wrapper.state('videoList')).toEqual(null)&#125;) 代码覆盖率代码覆盖率是一个测试指标，用来描述测试用例的代码是否都被执行。统计代码覆盖率一般要借助代码覆盖工具，Jest内置代码覆盖工具。 四个测量维度 行覆盖率(line coverage)：是否测试用例的每一行都执行了 函数覆盖率(function coverage)：是否测试用例的每一个函数都调用了 分支覆盖率(branch coverage)：是否测试用例的每个if代码块都执行了 语句覆盖率(statement coverage)：是否测试用例的每个语句都执行了 antd-pro 中遇到的问题 jest报错： 1SecurityError: localStorage is not available for opaque origins https://github.com/facebook/jest/issues/6769 解决方案： 下载了一个最新版的antd-pro 2.0，居然解决了，😠生气 就是在目录下加了一个jest.config.js文件，里面的内容是： 123module.exports = &#123; testURL: 'http://localhost:8000',&#125; 获取Panel header中的组件 1console.log(shallow(wrapper.find('CollapsePanel').prop('header')).debug()) antd组件必须这么引用，否则jest会报错 const Panel = Collapse.Panel upload的beforeupload方法无法模拟触发 123456&lt;Upload fileList=&#123;audioList&#125; disabled=&#123;audioList &amp;&amp; audioList.length &gt; 0&#125; beforeUpload=&#123;this.handleBeforeUpload&#125; onRemove=&#123;this.handleFileRemove&#125;/&gt; expect随机数 123456789101112131415161718192021it('will check the matchers and pass', () =&gt; &#123; const user = &#123; createdAt: new Date(), id: Math.floor(Math.random() * 20), name: 'LeBron James', &#125; expect(user).toMatchSnapshot(&#123; createdAt: expect.any(Date), id: expect.any(Number), &#125;)&#125;)// Snapshotexports[`will check the matchers and pass 1`] = `Object &#123; "createdAt": Any&lt;Date&gt;, "id": Any&lt;Number&gt;, "name": "LeBron James",&#125;` or 1Date = jest.fn(() =&gt; 1482363367071) HOC connect(container) antd pro推荐这种做法： 被 dva connect 的 React 组件可以使用下面方式进行测试。 1234567891011import React from 'react'import &#123; shallow &#125; from 'enzyme'import Dashboard from './Dashboard'it('renders Dashboard', () =&gt; &#123; // 使用包装后的组件 const wrapper = shallow( &lt;Dashboard.WrappedComponent user=&#123;&#123; list: [] &#125;&#125; /&gt; ) expect(wrapper.find('Table').props().dataSource).toEqual([])&#125;) 关于Component.WrappedComponent The wrapped component is exposed as the static property WrappedComponent on the returned component, which can be used for testing the component in isolation, among other things. 123456// MyComponent.jsexport default withRouter(MyComponent)// MyComponent.test.jsimport MyComponent from './MyComponent'render(&lt;MyComponent.WrappedComponent location=&#123;&#123;...&#125;&#125; ... /&gt;) HOC withRouter(container) redux官方推荐这种做法： 1234567import &#123; connect &#125; from 'react-redux'​// Use named export for unconnected component (for tests)export class App extends Component &#123; /* ... */ &#125;​// Use default export for the connected component (for app)export default connect(mapStateToProps)(App) mock dispatch 1const dispatch = jest.fn().mockResolvedValue('default') 总结 Jest + Enzyme 写单元测试快速方便 Snapshot简单易用，在不追求测试覆盖率的情况下，可以简单写几个snapshot 单元测试对于写更好的代码，很有帮助 参考文献 https://zh.wikipedia.org/wiki/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95 https://jestjs.io/docs/zh-Hans/getting-started.html https://airbnb.io/enzyme/ http://react-china.org/t/jest-enzyme-react/11769 https://github.com/facebook/create-react-app/blob/master/packages/react-scripts/template/README.md#initializing-test-environment https://www.youtube.com/watch?v=8Ww2QBVIw0I&amp;feature=youtu.be https://github.com/ned-alyona/posts/tree/master/jest-enzyme-testing https://juejin.im/post/5b6c39bde51d45195c079d62 http://echizen.github.io/tech/2017/04-24-component-lifycycle-test https://medium.com/@newyork.anthonyng/use-jest-snapshot-on-everything-4c5d4c88ca16 https://hackernoon.com/snapshot-testing-react-components-with-jest-744a1e980366 https://blog.bitsrc.io/how-to-test-react-components-using-jest-and-enzyme-fab851a43875 https://pro.ant.design/docs/ui-test-cn https://cn.redux.js.org/docs/recipes/WritingTests.html https://hackernoon.com/testing-react-components-with-jest-and-enzyme-41d592c174f https://github.com/r-walsh/react-unit-test-practice]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac高效开发小技巧]]></title>
    <url>%2F%2Fblog%2F2018%2F09%2FMac%E9%AB%98%E6%95%88%E5%BC%80%E5%8F%91.html</url>
    <content type="text"><![CDATA[ssh别名用户名、IP 地址和端口号还是不想记忆，此时可以利用 SSH 的配置文件来实现。 编辑 ~/.ssh/config 文件，添加以下内容： 12345Host testhost HostName 1.2.3.4 User root Port 54321 IdentityFile ~/.ssh/id_rsa 这个配置文件还是很容易理解的，我们给地址为 1.2.3.4，端口为 54321，用户名为 root 的远程主机起了一个别名，然后就可以这样连接了： 1ssh testhost 再也不用担心自己记不住那么多远程主机 vim操作行和屏幕移动Vim 的翻页快捷键是： 1234Ctrl + f：向后翻一页（forward）Ctrl + b：向前翻一页（backward）Ctrl + d：向后翻半页（down）Ctrl + u：向前翻半页（up） 文本编辑 在普通模式下，按下 o会快速进入输入模式，并且在下一行进行编辑 按下大写的O会在上一行编辑 I 前往行头开始编辑 A 跳转到行尾编辑 撤销与重做 撤销上一次修改，可以用 u，类似于系统的 Command + z 快捷键 重做，可以用 Ctrl + R，类似于系统的 Command + Shift + z 快捷键]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>macbook</tag>
        <tag>ssh</tag>
        <tag>vi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[literallycanvas的简介]]></title>
    <url>%2F%2Fblog%2F2018%2F08%2Fliterallycanvas%E7%AE%80%E4%BB%8B.html</url>
    <content type="text"><![CDATA[git项目目录： _static literallycanvas的依赖文件 classic_style 用普通js的方式编写的用例 react_style 基于create-react-app编写的用例 freecanvas-demo 二次开发，基本实现了图片旋转功能 xmind api介绍 LiterallyCanvas是什么Literally Canvas是一个可扩展的开源（BSD许可）HTML5绘图组件，可以用于网页中插入画图板，类似于windows自带的画图板。可以用可视化工具绘制图画，同时提供api完成相同的功能，也可以将结果导出。它依赖于React.js，所以很方便在react项目中使用。 特性 基本的绘画工具 编码自定义绘画工具 平移和缩放 背景图、水印 支持Retina 保存和加载 JSON 输出图片到PNG或SVG 丰富的API 无缝接入React 开源 快速上手 加载literallycanvas 普通方式 123456789101112131415161718192021&lt;html&gt;&lt;head&gt; &lt;!-- 需要react --&gt; &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.14.7/react-with-addons.js"&gt;&lt;/script&gt; &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.14.7/react-dom.js"&gt;&lt;/script&gt; &lt;!-- literallycanvas的js文件 --&gt; &lt;script src="../_static/js/literallycanvas.js"&gt;&lt;/script&gt; &lt;!-- literallycanvas的css文件 --&gt; &lt;link href="../_static/css/literallycanvas.css" rel="stylesheet"&gt; &lt;title&gt;literallycanvas-with-gui&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="my-drawing"&gt;&lt;/div&gt; &lt;script&gt; LC.init( document.getElementsByClassName('my-drawing')[0], &#123; imageURLPrefix: '../_static/img'&#125; ); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; react方式 12345678910111213import React, &#123; PureComponent &#125; from 'react'import &#123; LiterallyCanvasReactComponent &#125; from 'literallycanvas'import 'literallycanvas/lib/css/literallycanvas.css'export default class Exmaple1 extends PureComponent &#123; render() &#123; return ( &lt;div className="App"&gt; &lt;LiterallyCanvasReactComponent imageURLPrefix="static/img" /&gt; &lt;/div&gt; ) &#125;&#125; package.json1234567891011121314151617181920&#123; "name": "react_style_literally", "version": "0.1.0", "private": true, "description": "目前版本0.4.13不支持react16以上，v5.0以上支持", "dependencies": &#123; "react": "^15.6.0", "react-dom": "^15.6.0", "react-scripts": "1.1.4", "react-router-dom": "^4.3.1", "literallycanvas": "0.4.13" &#125;, "scripts": &#123; "start": "react-scripts start", "build": "react-scripts build", "test": "react-scripts test --env=jsdom", "eject": "react-scripts eject" &#125;&#125; (!!!官网方式不靠谱)12345678910111213141516171819202122232425&lt;html&gt; &lt;head&gt; &lt;!-- stylesheet --&gt; &lt;link href="/static/css/literallycanvas.css" rel="stylesheet"&gt; &lt;!-- dependency: React.js --&gt; &lt;script src="//cdnjs.cloudflare.com/ajax/libs/react/0.14.7/react-with-addons.js"&gt;&lt;/script&gt; &lt;script src="//cdnjs.cloudflare.com/ajax/libs/react/0.14.7/react-dom.js"&gt;&lt;/script&gt; &lt;script src="//cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js"&gt;&lt;/script&gt; &lt;!-- Literally Canvas --&gt; &lt;script src="/static/js/literallycanvas.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="root"&gt;&lt;/div&gt; &lt;script type="text/babel"&gt; ReactDOM.render( &lt;div&gt; &lt;LC.LiterallyCanvasReactComponent imageURLPrefix="/static/img" /&gt; &lt;/div&gt;, document.getElementById('root')); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 修改样式（修改画图板的宽高） 宽度，可以通过修改父组件宽度来修改 高度，原有样式为min-hight:400px,修改父组件不好使1234567891011.my-drawing &#123; /* 宽度可自定义 */ width: 1000px; /* 高度无效 */ height: 600px;&#125;/* 覆盖literally样式 */.my-drawing .literally &#123; height: 600px;&#125; 原理 两个canvas叠加，一个负责渲染背景内容，一个负责渲染涂画操作 API init shapes snapshot … 示例代码 二次开发 下载源码 git clone https://github.com/literallycanvas/literallycanvas.git 源码目录 基于coffee-script开发（看不懂的，可以选择读lib目录下的js） 打包 执行gulp命令生成新的lib/js/literallycanvas.js 如果是基于react的修改，怎么办？ 本地修改保持不变 自己打一个npm包 给该项目发起Pull Request 总结 优点： 比其他开源画图工具功能更加强大，其他的只提供基本的图片展示、画笔、橡皮擦功能 无缝接入react项目 开源 可扩展，使用API 速度快github上满足批改后台需求的最合适项目 缺点： 更新缓慢 配置文件不够细，不能满足某些需求 功能不满足：1）图片旋转(如有需要，可使用freecanvas这个npm包，这是我基于literallycanvas开发的，增加了图片旋转功能)2）文字添加后可移动位置]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Literallycanvas</tag>
      </tags>
  </entry>
</search>
