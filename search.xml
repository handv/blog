<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2021前端社招面试总结之算法篇]]></title>
    <url>%2F%2Fblog%2F2021%2F07%2F2021%E5%89%8D%E7%AB%AF%E7%A4%BE%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%E4%B9%8B%E7%AE%97%E6%B3%95%E7%AF%87.html</url>
    <content type="text"><![CDATA[首次前端社招经验总结，大概分算法篇、编程篇、前端技术篇三部分。本次是算法篇的内容。算法程度对于前端来说，算法在面试中所占比例不是很高，题目难度也不是特别大，大部分属于 leetcode 简单题、中等题偏简单题目。对于社招前端而言，手写代码还是以考察实际项目编程为主，这个我们后续再讲。 考察范围也主要以数组、字符串、树为主。在我的面试过程中，也只遇到过一次动态规划类型的题目。 所以大家在准备过程中，针对性的做一些数组、字符串、二叉树的简单、中等题目即可。没有学过动态规划的，可以暂时放弃这部分，免得浪费面试准备时间。 面试过程中遇到的算法题数组 给定一个多重嵌套数组，拍平并去重 (难度：简单) 1234567891011121314151617181920212223242526272829303132333435363738const arr = [ [3, 9, 2, 4], [99, 32, 5, 7, 3], [6, 3, 12, 45, 9, [11, 8, [22, 15, 313, [44]]]], 10, [99, 32],]// 方法1function flatAndNoRepeat(arr) &#123; const res = [] function innerFunc(arr) &#123; for (let item of arr) &#123; // 先判断item是否为数组 if (Array.isArray(item)) &#123; // 数组的话，递归调用innerFunc方法 innerFunc(item) &#125; else if (!res.includes(item)) &#123; // 非数组，则判断res中是否已包含该item。不包含则加入 res.push(item) &#125; &#125; &#125; return res&#125;// 方法2 把res由数组换成setfunction flatAndNoRepeat(arr) &#123; const res = new Set() function innerFunc(arr) &#123; for (let item of arr) &#123; if (Array.isArray(item)) &#123; innerFunc(item) &#125; else &#123; res.add(item) &#125; &#125; &#125; return [...res]&#125; tips: 数组去重的小技巧 12const arr = [10, 10, 20, 30, 34, 30]const res = [...new Set(arr)] // [10,20,30,34] 将两个有序数组合并成一个有序数组 (难度：简单) 1234567891011121314151617181920212223242526272829303132333435363738- 将两个有序数组合并成一个有序数组- @param &#123;number[]&#125; A 有序数组 A- @param &#123;number[]&#125; B 有序数组 B- @returns &#123;numbers[]&#125; 合并后的有序数组- @example- const A = [1,2,7,8];- const B = [3,4,5,6];- mergeSorted(A, B); // 返回 [1,2,3,4,5,6,7,8]function mergeSorted(A, B) &#123; const res = []; const aLen = A.length; const bLen = B.length; let aindex = 0, bindex = 0; // 取A、B中小的数值，放入res数组中 while(aindex &lt; aLen &amp;&amp; bindex &lt; bLen) &#123; if (A[aindex] &lt;= B[bindex]) &#123; res.push(A[aindex]); aindex++; &#125;else &#123; res.push(B[bindex]); bindex++; &#125; &#125; // 如果A或者B中还有剩余值，则依次加入到res数组中 while(aindex &lt; aLen) &#123; res.push(A[aindex]); aindex++; &#125; while(bindex &lt; bLen) &#123; res.push(B[bindex]); bindex++; &#125; return res;&#125; 给定一个数据结构 A，转成树形结构 B (难度：中等) 1234567891011121314151617181920212223242526272829303132333435const A = [ &#123;id: 2, parentId: 1&#125;, &#123;id: 1&#125;, &#123;id: 3, parentId: 2&#125;, &#123;id: 5, parentId: 4&#125;, &#123;id: 4&#125;,]const B = [ &#123;id: 1, child: [&#123;id: 2, parentId: 1, child: [&#123;id: 3, parentId: 2&#125;]&#125;]&#125;, &#123;id: 4, child: [&#123;id: 5, parentId: 4&#125;]&#125;,]function parseTree(A) &#123; const res = &#123;&#125; const root = Symbol(0) A.forEach((item) =&gt; &#123; const &#123;id, parentId&#125; = item if (!res[id]) &#123; res[id] = &#123;...item, child: []&#125; &#125; else &#123; res[id] = &#123;...res[id], ...item&#125; &#125; // 给没有parentId的id一个父节点 const parent = parentId || root if (!res[parent]) &#123; res[parent] = &#123;id: parent, child: [res[id]]&#125; &#125; else &#123; // 因为push的是res[id]引用类型，所以res[id]变化，res[parent].child的内容自然也会变化 res[parent].child.push(res[id]) &#125; &#125;) return res[root].child&#125; 字符串 实现字符串中单词按数字顺序从小到大排序，比如：(难度：简单) ‘ac23dd rf5 8ee’ -&gt; ‘rf5 8ee ac23dd’ 123456789101112131415161718function sortByNum(str) &#123; // 取出各个单词中的数字部分 function getNum(string) &#123; let num = 0 for (let char of string) &#123; if (/\d/.test(char)) &#123; num = num * 10 + Number(char) &#125; &#125; return num &#125; // 按空格划分单词数组 const arr = str.split(' ') // 数组按数字大小排序 arr.sort((a, b) =&gt; getNum(a) - getNum(b)) return arr.join(' ')&#125; 把数字12345转换成千位分隔符方式12,345 (难度：简单) 1234567891011121314151617181920// 方法1，从后往前排，3个一组，加逗号function parseNum(number) &#123; let res = '' let count = 1 for (let i = number.length - 1; i &gt; 0; i--) &#123; res = number[i] + res if (count % 3 === 0) &#123; res = ',' + res &#125; count++ &#125; res = number[0] + res return res&#125;// 方法2：正则表达式function parseNum(number) &#123; // 非首位，后续是连续3个数字的位置，变成',' return str.replace(/(?!^)(?=(\d&#123;3&#125;)+$)/g, ',')&#125; 给定两个字符串 str1 和 str2，输出两个字符串的最长公共子序列。如过最长公共子序列为空，则输出-1 (难度：中等) 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。 例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。 输入“1A2C3D4B56”,”B1D23CA45B6A”输出“123456”说明“123456”和“12C4B6”都是最长公共子序列，任意输出一个。 123456789101112131415161718192021222324252627282930313233// 动态规划function longestCommonSubsequence(str1, str2) &#123; const len1 = str1.length const len2 = str2.length const dp = new Array(len1 + 1).fill(0).map(() =&gt; new Array(len2 + 1).fill(0)) // dp[i][j]表示str1[0, i] str2[0, j]的最长公共子序列的长度 for (let i = 1; i &lt;= len1; i++) &#123; for (let j = 1; j &lt;= len2; j++) &#123; if (str1[i - 1] === str2[j - 1]) &#123; dp[i][j] = dp[i - 1][j - 1] + 1 &#125; else &#123; dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]) &#125; &#125; &#125; // 求公共子序列 let res = '' for (let i = len1, j = len2; dp[i][j] &gt; 0; ) &#123; if (str1[i - 1] === str2[j - 1]) &#123; res = str1[i - 1] + res i-- j-- &#125; else if (dp[i - 1][j] &gt;= dp[i][j - 1]) &#123; i-- &#125; else &#123; j-- &#125; &#125; return res === '' ? -1 : res&#125; 扩展题目 二叉树 找出二叉树中某两个节点的第一个共同祖先，不得将其他的节点存储在另外的数据结构中。 (难度：中等) 12345678function findCommonAncestor(root, nodeA, nodeB) &#123; if (!root || root === nodeA || root === nodeB) return root const lnode = findCommonAncestor(root.left, nodeA, nodeB) const rnode = findCommonAncestor(root.right, nodeA, nodeB) if (!lnode) return rnode if (!rnode) return lnode return root // p、q分列左右子树上，则root为最近父节点&#125; 二叉树的广度优先遍历 (难度：中等) 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; */function bfs(root) &#123; if (!root || root.length) return [] const queue = [] const res = [] queue.push(root) // 队列用来按层载入数据 while (queue.length) &#123; // 获取该层所有数据个数 let len = queue.length const arr = [] while (len) &#123; // 吐出该层所有node const node = queue.shift() arr.push(node.val) node.left &amp;&amp; queue.push(node.left) node.right &amp;&amp; queue.push(node.right) len-- &#125; res.push(arr) &#125; return res&#125; 其他 随机从数组中取 5 个人，每次都跟前一次不一样 (难度：简单) 12345678910111213141516function randomPick(arr, count) &#123; const len = arr.length let res = [] let preItem = null for (let i = 0; i &lt; count; ) &#123; // 获取[0, len)的随机数 const index = Math.floor(Math.random() * len) const curItem = arr[index] if (!res.includes(curItem) &amp;&amp; preItem !== curItem) &#123; res.push(curItem) preItem = curItem i++ &#125; &#125; return res&#125; 给你一个字符串表达式 s (3 + 2) / 4 * 5，请你实现一个基本计算器来计算并返回它的值。 (难度：困难) 此题为 leetcode 会员解锁，解题思路可参考这里 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105// nums存放数字let nums = []// opts存放运算符let opts = []// 运算符权重const optweight = &#123; '*': 2, '/': 2, '+': 1, '-': 1,&#125;var calculate = function (s) &#123; nums = [] opts = [] nums.push(0) // 防止第一个数为负数时的异常 s = s.replaceAll(' ', '') let num = 0 const len = s.length for (let i = 0; i &lt; len; ) &#123; const item = s[i] if (/\d/.test(item)) &#123; // 在这里计算当前所有数字内容，放入nums数组中 while (/\d/.test(s[i])) &#123; num = 10 * num + Number(s[i]) i++ &#125; nums.push(num) num = 0 &#125; else &#123; switch (item) &#123; case '(': opts.push(item) break case ')': &#123; while (opts.length) &#123; // 取左括号后的所有运算符，进行运算 if (opts[opts.length - 1] !== '(') &#123; cal() &#125; else &#123; // 吐出左括号，退出循环 opts.pop() break &#125; &#125; break &#125; case '+': case '-': case '*': case '/': &#123; // 如果上一个字符也是符号，如+-3，则给nums加个0 if (i &gt; 0 &amp;&amp; ['(', '+', '-'].includes(s[i - 1])) &#123; nums.push(0) &#125; // 如果运算符数组中有运算符，且最后一个运算符不是左括号 while (opts.length &amp;&amp; opts[opts.length - 1] !== '(') &#123; // 如果opts内的最后一个运算符权重比当前运算符大，则要先计算里面的 if (optweight[opts[opts.length - 1]] &gt;= optweight[item]) &#123; cal() &#125; else &#123; break &#125; &#125; opts.push(item) break &#125; default: break &#125; i++ &#125; &#125; while (opts.length) &#123; cal() &#125; return nums.reduce((pre, cur) =&gt; pre + cur)&#125;function cal() &#123; // 没有两个以上数字，不计算 if (nums.length &lt; 2) return let res = 0 // 取出nums中最后两个数字，opts中最后一个运算符，进行计算 const a = nums.pop() const b = nums.pop() switch (opts.pop()) &#123; case '+': res = a + b break case '-': res = b - a break case '*': res = a * b break case '/': res = (b / a) | 0 break default: break &#125; nums.push(res)&#125; tips: 题目有点难，可以先完成这两道题基本计算器和基本计算器 II做练习 顺时针打印矩阵 (难度：简单) 1234567891011121314151617181920212223242526272829303132333435const arr = [ [1, 2, 3], [4, 5, 6], [7, 8, 9],]// N * N// 扁平化输出、顺时针向内打印// out put [1,2,3,6,9,8,7,4,5]function flat(arr) &#123; const res = [] const len = arr.length const n = arr[0].length let index = 0 while (res.length &lt; len * n) &#123; // 找规律 for (let i = index; i &lt; len - index; i++) &#123; res.push(arr[index][i]) &#125; for (let i = index + 1; i &lt; n - index; i++) &#123; res.push(arr[i][len - index - 1]) &#125; for (let i = len - index - 2; i &gt;= index; i--) &#123; res.push(arr[len - index - 1][i]) &#125; for (let i = n - index - 2; i &gt; index; i--) &#123; res.push(arr[i][index]) &#125; index++ &#125; return res&#125; 扩展题目 判断一个点是否在三角形内部 (难度：中等) 该题主要用到数学知识]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《webpack 实战（入门、进阶与调优）》笔记]]></title>
    <url>%2F%2Fblog%2F2021%2F06%2Fwebpack%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[《webpack 实战（入门、进阶与调优）》笔记第 2 章 模块打包2.3 commonJs 和 es6 module 的区别 commonjs、在代码执行阶段加载；es6 module 在代码编译阶段加载 可以用 if 来判断是否加载某个 commonJs es6 module 的导入、导出都是声明式的，必须位于模块的顶层作用域，不能放在 if 语句中 comonjs 导入的是一个对象，而 es6 module 支持直接导入变量，减少了引用层级，程序效率更高 123456// commonjsmodule.exports = &#123; name: 'a'&#125;// es6 moduleexport name = 'a' commonjs 导入的是导出值的一个值拷贝，而 es6 modlue 则是导出值的动态映射，并且这个映射是只读的 以下代码中，count 不能重新赋值 123456789101112import &#123;count, add&#125; from './calculator.js'console.log(count, 1)add(1, 2)console.log(count, 2)// 此处会报错，Cannot use import statement outside a module// count = 3;console.log(count, 3) 如何处理循环依赖 commonJs A 依赖 B， B 依赖 C， C 也依赖 B 12345678910111213141516// foo.jsconst bar = require('./bar.js');console.log('value of bar:', bar);module.exports = 'foo.js'// bar.jsconst foo = require('./foo.js');console.log('value of foo:', foo);module.exports = 'bar.js'// index.jsrequire('./foo.js')// 输出结果：value of foo: &#123;&#125;value of bar: bar.js 解释： index.js 导入 foo.js，开始执行 foo.js foo.js 的第一句引入 bar.js，此时 foo.js 不会往下执行了，开始执行 bar.js 在 bar.js 中又对 foo.js 进行了引用，这里产生了循环。但不会再跳回 foo.js 中执行，而是直接取其导出值。又因为 foo.js 还没执行到导出行 13 行，所以导出值为默认值{}。 从 webpack 的角度来看： 123456789101112function __webpack_require__(moduleId) &#123; if(installedModules[moduleId]) &#123; return installedModules[moduleId].exports &#125;else &#123; var module = installedModules[moduleId] = &#123; id: moduleId, loaded: false, exports: &#123;&#125; &#125; ... &#125;&#125; 当 index.js 引用 foo.js 时，相当于执行了webpack_require，初始化了一个 module 对象 installedModules[‘foo.moduleId’]，其 exports={}，当 bar.js 再次引用 foo.js 时，又执行了webpack_require，此时 installedModules[‘foo.moduleId’]已存在，其 exports 为{} es6 module 同样，在 es6module 中，也无法获得 foo.js 正确的导出值，只不过 es6module 导出的是 undefined，而不是空对象{}。但因为 es6module import 的是引用，所以他可以更好的支持循环依赖，只不过需要开发者来保证。（解决依赖冲突的方法，可以参考原书 P32） 2.4 加载其他类型模块2.4.1 非模块化文件一个放在 script 标签中的文件 1&lt;script src="./jquery.js"&gt;&lt;/script&gt; 如何在 webpack 中引入 jquery 等非模块化文件呢，直接 1import './jquery.js' 这句代码会直接执行 jquery.js 2.4.4 加载 npm 模块 每个 npm 模块都有一个入口文件，被维护在模块内部 package.json 中的 main 字段。 除了直接加载模块，还可以通过&lt;package_name&gt;/的形式单独加载 npm 包内部的某个 js 文件，如： import all from &#39;lodash/fp/all.js&#39;，这样子 webpack 最终只会打包 node_module/lodash/fp/all.js，不会打包全部的 lodash 库。 2.5 模块打包原理 webpack 初始化，定义好一些内容，如webpack_require函数、installedModules 对象 加载入口模块 执行模块代码，执行到 module.exports 就记录下导出值；遇到 require 函数，就交出执行权，进入webpack_require去加载其他模块 在webpack_require中判断当前模块在 installedModules 是否存在，存在则直接返回，不存在则进入 3 所有模块加载完毕后，又回到入口模块，继续执行到结尾。 第 3 章 资源输入输出 module、chunk、bundle 的区别 module，码农开发写的代码模块 chunk，webpack 打包过程中的分块，通常一个 module 一个 chunk bundle，打包完成后的文件，通常一个 chunk 一个 bundle，但如果用 loader\plugin 对代码进行了拆分处理等，一个 chunk 可能对应多个 bundle。比如一个 index 入口文件，会单独拆出一个 index.css 文件。 fielname、chunkfilename filename，入口文件名chunkfilename，不在 entry 中，但被打包出来的文件名 publicpath 第 4 章 预处理器 loader webpack 中配置格式 1234567891011module.exports = &#123; ..., module: &#123; rules: [ &#123; test: /.css/, use: ['style-loader', 'css-loader'] // loader使用顺序从后向前 &#125; ] &#125;&#125; 常用 loader bable-loader url-loader，处理图片 第 5 章 样式处理 css-loader，识别 css 文件 style-loader，将打包后的 css 内容添加到 header 的 style 标签里 postcss-loader\less-loader\sass-loader stylelint css moduels css-loader 的 options 开启 module:true 即可。 第 6 章 代码分片6.3 optimization.splitChunks12345678910111213141516171819202122module.exports = &#123; ..., optimization: &#123; ..., splitChunks: &#123; // chunks默认为'async'，只拆分异步模块。如使用import('lodash')这种形式加载的模块 // all对所有同步、异步模块都拆分。 chunks: 'all', name: false, // 默认情况下有两种规则，vendors和default // vendors提取所有node_modules中符合条件的模块 // default提取被多次引用的模块 cacheGroups: &#123; react: &#123; test: /react/, name: 'react', priority: 20, &#125;, &#125;, &#125;, &#125;&#125; 第 7 章 生产环境配置7.2 开启 production 模式webpack 配置 mode 为 production，可自动添加很多适用于生产环境的配置项，减少手动的工作。如： 把 treeshaking 标记为死代码的代码，去除掉 默认开启代码分片 自动设置 process.env.NODE_ENV 自动开启代码压缩 7.3 环境变量可通过 DefinePlugin 设置自定义环境变量，通常用于 publicpath 打包地址的区分。 7.4 source-map7.4.3 安全既要保证上线后，使用可读性代码（source-map）来追踪 bug，又要保证安全性，不让别人看透你的代码。source-map 提供三种解决方案： hidden-source-map webpack 同样生成完整的 map 文件，但不会再 bundle 文件中添加对 map 文件的引用。可以将 map 文件上传到 sentry 来查看问题。 nosources-source-map 生成环境的代码仍然有 map，但是不会暴露代码内容。对于错误来说，仍然可以通过控制台来查看源码的错误栈。它对于追自动错误来说基本足够。 对.map 文件开放白名单 只允许公司内网查看.map 文件，外网无权限。 7.5 资源压缩7.5.1 压缩 jswebpack4 推荐 terser-webpack-plugin，不用 uglifyjs 了。 1234567891011121314module.exports = &#123; ..., optimization: &#123; minimize: true, minimizer: [ // This is only used in production mode new TerserPlugin(&#123; terserOptions: &#123; parallel: true // 默认为false，建议开发 &#125; &#125;) ] &#125;&#125; 7.5.2 压缩 css使用 mini-css-extract-plugin 提取样式到 css 文件，然后使用 optimize-css-assets-webpack-plugin 进行压缩。 7.6 缓存7.6.1 资源 hash参考webpack 中 contenthash 和 chunkhash 的区别 7.6.2 输出动态 html使用 html-webpack-plugin，可以自动在打包后把 js、css 等静态资源的 hash 名字映射到 html 文件的对应位置。 7.7 bundle 体积监控和分析 vscode 插件 Import Cost webpack-bundle-analyzer 插件 123456789const BundleAnalyzerPlugin = require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin;module.exports = &#123; ..., plugin: [ ..., new BundleAnalyzerPlugin(), ]&#125; 12345678&#123; ..., &quot;scripts&quot;: &#123; ..., &quot;build&quot;: &quot;node scripts/build.js&quot;, &quot;analyz&quot;: &quot;NODE_ENV=production npm_config_report=true yarn build&quot;, &#125;&#125; unused-webpack-plugin 插件(没研究出用法) 123456789101112const UnusedWebpackPlugin = require(&apos;unused-webpack-plugin&apos;);module.exports = &#123; ..., plugin: [ ..., new UnusedWebpackPlugin(&#123; directories: [path.join(__dirname, &apos;src&apos;)], root: __dirname &#125;) ]&#125; webpack 打包速度分析（书中没有，参考） 安装插件 speed-measure-webpack-plugin npm install --save-dev speed-measure-webpack-plugin 引入插件、创建插件对象 12const SpeedMeasurePlugin = require('speed-measure-webpack-plugin') //引入插件const smp = new SpeedMeasurePlugin() //创建插件对象 使用插件的 wrap()方法将配置包起来 123456789101112module.exports = smp.wrap(&#123; entry: &#123; index: './src/index.js', search: './src/search.js', &#125;, output: &#123; path: path.join(__dirname, 'dist'), //__dirname(当前模块的目录名) + dist filename: '[name]_[chunkhash:8].js', //打包后输出的文件名,添加文件指纹 chunkhash &#125;,plugpins: [],.....&#125;); 第 8 章 打包优化打包优化有两个方向： 打包速度 打包体积 打包速度：8.1 happypack(不推荐了，官方推荐用 thread-loader)8.2 缩小打包作用域打包体积：8.3 动态链接库和 DllPluginDllPlugin 和 splitChunks 有些类似，都是用来提取公共模块。但本质上有所区别： splitChunks，在打包过程中按照一定的规则提取模块 dllplugin，将 vendor 完全拆出来，有一个单独的 webpack.vendor.config.js 来进行配置，在实际构建的时候完全不对这部分代码处理。 总结来说，打包结果上，二者都会提取公共模块（如 node_module 中代码），但构建速度上，dllplugin 比 splitchunks 要快。 二者选其一使用就好，不要并存。（推荐用 splitchunks） 8.4 tree-shaking tree-shaking 依赖 es6 module 编译阶段分析能力，可以标记死代码。 tree-shaking 只对 es6 module 生效。有时候对依赖的 npm 包，tree-shaking 并没有生效，原因可能是该库是 commonjs 的方式导出的。虽然我们引用用了 import，但在该 npm 包内部，打包后的代码里，是用的 require。 tree-shaking，只是对死代码做标记，真正去除死代码是通过压缩工具，如 terser-webpack-plugin 或 uglifyplugin。在 webpack4 中，将 mode 设置为 production 也可以达到相同的效果。 runtimeChunkruntime 包含两部分： webpack 的运行环境(具体作用就是模块解析, 加载) ，比如打包后的代码里的webpack_require，这部分代码基本是不会变的。 包含 chunks 映射关系的 list。 单独从 app.js 里提取出来，避免映射关系的变化，影响 main.js 文件内容的变化。因为每一个 chunk 的 id 基本都是基于内容 hash 出来的，所以每次改动都会影响它，如果不将它提取出来的话，等于 app.js 每次都会改变。缓存就失效了。设置 runtimeChunk 之后，webpack 就会生成一个个 runtime~xxx.js 的文件。然后每次更改所谓的运行时代码文件时，打包构建时 app.js 的 hash 值是不会改变的。如果每次项目更新都会更改 app.js 的 hash 值，那么用户端浏览器每次都需要重新加载变化的 app.js，如果项目大切优化分包没做好的话会导致第一次加载很耗时，导致用户体验变差。现在设置了 runtimeChunk，就解决了这样的问题。所以这样做的目的是避免文件的频繁变更导致浏览器缓存失效，所以其是更好的利用缓存。提升用户体验。 12345678module.exports = &#123; //... optimization: &#123; runtimeChunk: &#123; name: (entrypoint) =&gt; `runtime~$&#123;entrypoint.name&#125;`, &#125;, &#125;,&#125; 第 9 章 开发环境调优9.2 模块热更新9.2.2 原理本地起一个 webpack-dev-server（wds）服务，打包的代码直接存在内存里。浏览器和 node 服务通过 websocket 通信。 当代码更新后，wds 会向浏览器推送更新事件，并带上这次构建的 hash，让浏览器与上一次资源进行对比。浏览器对比完发现 hash 变了，知道源码有更新，会请求 wds 获取更新文件的列表，这个请求的名字为[hash].hot-update.json。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[useState和setState]]></title>
    <url>%2F%2Fblog%2F2021%2F04%2FuseState%E5%92%8CsetState.html</url>
    <content type="text"><![CDATA[先来思考一个老生常谈的问题，setState是同步还是异步? 再深入思考一下，useState是同步还是异步呢？ 我们来写几个 demo 试验一下。 先看 useState同步和异步情况下，连续执行两个 useState 示例12345678910111213141516171819202122232425262728function Component() &#123; const [a, setA] = useState(1) const [b, setB] = useState('b') console.log('render') function handleClickWithPromise() &#123; Promise.resolve().then(() =&gt; &#123; setA((a) =&gt; a + 1) setB('bb') &#125;) &#125; function handleClickWithoutPromise() &#123; setA((a) =&gt; a + 1) setB('bb') &#125; return ( &lt;Fragment&gt; &lt;button onClick=&#123;handleClickWithPromise&#125;&gt; &#123;a&#125;-&#123;b&#125; 异步执行 &lt;/button&gt; &lt;button onClick=&#123;handleClickWithoutPromise&#125;&gt; &#123;a&#125;-&#123;b&#125; 同步执行 &lt;/button&gt; &lt;/Fragment&gt; )&#125; 结论： 当点击同步执行按钮时，只重新 render 了一次 当点击异步执行按钮时，render 了两次 同步和异步情况下，连续执行两次同一个 useState 示例1234567891011121314151617181920212223function Component() &#123; const [a, setA] = useState(1) console.log('a', a) function handleClickWithPromise() &#123; Promise.resolve().then(() =&gt; &#123; setA((a) =&gt; a + 1) setA((a) =&gt; a + 1) &#125;) &#125; function handleClickWithoutPromise() &#123; setA((a) =&gt; a + 1) setA((a) =&gt; a + 1) &#125; return ( &lt;Fragment&gt; &lt;button onClick=&#123;handleClickWithPromise&#125;&gt;&#123;a&#125; 异步执行&lt;/button&gt; &lt;button onClick=&#123;handleClickWithoutPromise&#125;&gt;&#123;a&#125; 同步执行&lt;/button&gt; &lt;/Fragment&gt; )&#125; 当点击同步执行按钮时，两次 setA 都执行，但合并 render 了一次，打印 3 当点击异步执行按钮时，两次 setA 各自 render 一次，分别打印 2，3 再看 setState同步和异步情况下，连续执行两个 setState 示例12345678910111213141516171819202122232425262728293031class Component extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; a: 1, b: 'b', &#125; &#125; handleClickWithPromise = () =&gt; &#123; Promise.resolve().then(() =&gt; &#123; this.setState(&#123;...this.state, a: 'aa'&#125;) this.setState(&#123;...this.state, b: 'bb'&#125;) &#125;) &#125; handleClickWithoutPromise = () =&gt; &#123; this.setState(&#123;...this.state, a: 'aa'&#125;) this.setState(&#123;...this.state, b: 'bb'&#125;) &#125; render() &#123; console.log('render') return ( &lt;Fragment&gt; &lt;button onClick=&#123;this.handleClickWithPromise&#125;&gt;异步执行&lt;/button&gt; &lt;button onClick=&#123;this.handleClickWithoutPromise&#125;&gt;同步执行&lt;/button&gt; &lt;/Fragment&gt; ) &#125;&#125; 当点击同步执行按钮时，只重新 render 了一次 当点击异步执行按钮时，render 了两次 跟useState的结果一样 同步和异步情况下，连续执行两次同一个 setState 示例123456789101112131415161718192021222324252627282930class Component extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; a: 1, &#125; &#125; handleClickWithPromise = () =&gt; &#123; Promise.resolve().then(() =&gt; &#123; this.setState(&#123;a: this.state.a + 1&#125;) this.setState(&#123;a: this.state.a + 1&#125;) &#125;) &#125; handleClickWithoutPromise = () =&gt; &#123; this.setState(&#123;a: this.state.a + 1&#125;) this.setState(&#123;a: this.state.a + 1&#125;) &#125; render() &#123; console.log('a', this.state.a) return ( &lt;Fragment&gt; &lt;button onClick=&#123;this.handleClickWithPromise&#125;&gt;异步执行&lt;/button&gt; &lt;button onClick=&#123;this.handleClickWithoutPromise&#125;&gt;同步执行&lt;/button&gt; &lt;/Fragment&gt; ) &#125;&#125; 当点击同步执行按钮时，两次 setState 合并，只执行了最后一次，打印 2 当点击异步执行按钮时，两次 setState 各自 render 一次，分别打印 2，3 这里跟useState不同，同步执行时useState也会对state进行逐个处理，而setState则只会处理最后一次 为什么会有同步执行和异步执行结果不同呢？这里就涉及到 react 的 batchUpdate 机制，合并更新。 首先，为什么需要合并更新呢？ 如果没有合并更新，在每次执行 useState 的时候，组件都要重新 render 一次，会造成无效渲染，浪费时间（因为最后一次渲染会覆盖掉前面所有的渲染效果）。所以 react 会把一些可以一起更新的 useState/setState 放在一起，进行合并更新。 怎么进行合并更新 这里 react 用到了事务机制。 React 中的 Batch Update 是通过「Transaction」实现的。在 React 源码关于 Transaction 的部分，用一大段文字及一幅字符画解释了 Transaction 的作用： 12345678910111213141516171819202122* wrappers (injected at creation time)* + +* | |* +-----------------|--------|--------------+* | v | |* | +---------------+ | |* | +--| wrapper1 |---|----+ |* | | +---------------+ v | |* | | +-------------+ | |* | | +----| wrapper2 |--------+ |* | | | +-------------+ | | |* | | | | | |* | v v v v | wrapper* | +---+ +---+ +---------+ +---+ +---+ | invariants* perform(anyMethod) | | | | | | | | | | | | maintained* +-----------------&gt;|-|---|-|---|--&gt;|anyMethod|---|---|-|---|-|--------&gt;* | | | | | | | | | | | |* | | | | | | | | | | | |* | | | | | | | | | | | |* | +---+ +---+ +---------+ +---+ +---+ |* | initialize close |* +-----------------------------------------+ 用大白话说就是在实际的 useState/setState 前后各加了段逻辑给包了起来。只要是在同一个事务中的 setState 会进行合并（注意，useState不会进行state的合并）处理。 为什么 setTimeout 不能进行事务操作 由于 react 的事件委托机制，调用 onClick 执行的事件，是处于 react 的控制范围的。 而 setTimeout 已经超出了 react 的控制范围，react 无法对 setTimeout 的代码前后加上事务逻辑（除非 react 重写 setTimeout）。 所以当遇到 setTimeout/setInterval/Promise.then(fn)/fetch 回调/xhr 网络回调时，react 都是无法控制的。 相关react 源码如下 12345678if (executionContext === NoContext) &#123; // Flush the synchronous work now, unless we're already working or inside // a batch. This is intentionally inside scheduleUpdateOnFiber instead of // scheduleCallbackForFiber to preserve the ability to schedule a callback // without immediately flushing it. We only do this for user-initiated // updates, to preserve historical behavior of legacy mode. flushSyncCallbackQueue()&#125; executionContext 代表了目前 react 所处的阶段，而 NoContext 你可以理解为是 react 已经没活干了的状态。而 flushSyncCallbackQueue 里面就会去同步调用我们的 this.setState ，也就是说会同步更新我们的 state 。所以，我们知道了，当 executionContext 为 NoContext 的时候，我们的 setState 就是同步的 总结我们来总结一下上述实验的结果： 在同步事件中 多次执行setState和useState，只会调用一次重新渲染render 不同的是，setState会进行state的合并，而useState则不会 在异步的事件中（如setTimeout，Promise.then) 多次执行setState和useState，每一次的执行setState和useState，都会调用一次render 参考资料 https://github.com/facebook/react/blob/b1768b5a48d1f82e4ef4150e0036c5f846d3758a/src/renderers/shared/stack/reconciler/Transaction.js#L19-L54 https://zhuanlan.zhihu.com/p/78516581 https://github.com/facebook/react/issues/10231 https://zhuanlan.zhihu.com/p/28532725 https://medium.com/swlh/react-state-batch-update-b1b61bd28cd2 https://zhuanlan.zhihu.com/p/350332132 https://juejin.cn/post/6844903886407352334]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>源码</tag>
        <tag>知识点</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas生成base64图片失败的问题]]></title>
    <url>%2F%2Fblog%2F2021%2F02%2Fcanvas%E7%94%9F%E6%88%90base64%E5%9B%BE%E7%89%87%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[bug最近在做需求的时候，需要自行把生成图片，自然而然的用到了canvas.toDataURL这个api来生成base64的图片。 但是在实际测试过程中，却发现在某些ios手机中，无论是safari还是微信环境，都无法正常生成base64内容，而只是生成”data:,”就结束了。但出问题的设备环境，无论是ios版本号还是iphone手机型号，都比较随机。 debug经过调试，发现当更改canvas画布的高度尺寸，设置高度&lt;1500时，就正常生成图片了，但是&gt;1500就有问题。 查找资料和做试验发现，所有浏览器都对canvas画布尺寸有一定的宽高限制，都超过这个尺寸时，生成canvas就图裂了（如下图↓），自然也无法生成base64。 大家可以在pc的chrome里打开如下代码试一下： 123456789var canvas = document.createElement("canvas");canvas.width = 100000;canvas.height = 100000;var ctx = canvas.getContext('2d');ctx.fillStyle = '#f00';ctx.fillRect(0, 0, 2000, 2000);var base = canvas.toDataURL();console.log(base);document.body.appendChild(canvas); 看来，ios的safari对宽高的限制要求比较高。 fix如此一来，我们的解决方案就是限制canvas画布的宽高尺寸，而且不能丢失图片的内容，那就只能用缩放手段了。解决方案大致如下： 12345678910var canvas = document.createElement("canvas");var scale = 0.1;canvas.width = 100000 * scale;canvas.height = 100000 * scale;var ctx = canvas.getContext('2d');ctx.fillStyle = '#f00';ctx.fillRect(0, 0, 2000, 2000);var base = canvas.toDataURL();console.log(base);document.body.appendChild(canvas); 参考资料 https://www.cnblogs.com/shuchong/p/5948542.html https://segmentfault.com/q/1010000007675294]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>Canvas</tag>
        <tag>备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack中contenthash和chunkhash的区别]]></title>
    <url>%2F%2Fblog%2F2021%2F01%2Fwebpack%E4%B8%ADcontenthash%E5%92%8Cchunkhash%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
    <content type="text"><![CDATA[背景最近遇到一个问题，把一个 6 个月前在git ci上重新打包后，发现打包后的文件名的 hash 值跟之前不一样了，明明代码也没改啊，怎么回事？ 分析1分析一下，肯定是 webpack 打包的问题，我们的项目中用的是 contenthash，是不是换成 chunkhash 就好了呢？ hash, chunkhash 和 contenthash 的区别网上搜了一下 chunkhash 和 contenthash 的区别，写的挺模糊的。我们动手试验一下： contenthash创建一个 create-react-app，yarn eject 后，可以看到 config/webpack.config.js 中，默认配置的 hash 是 contenthash 1234567891011121314151617181920output: &#123; // The build folder. path: isEnvProduction ? paths.appBuild : undefined, // Add /* filename */ comments to generated require()s in the output. pathinfo: isEnvDevelopment, // There will be one main bundle, and one file per asynchronous chunk. // In development, it does not produce real files. filename: isEnvProduction ? 'static/js/[name].[contenthash:8].js' : isEnvDevelopment &amp;&amp; 'static/js/bundle.js', // TODO: remove this when upgrading to webpack 5 futureEmitAssets: true, // There are also additional JS chunk files if you use code splitting. chunkFilename: isEnvProduction ? 'static/js/[name].[contenthash:8].chunk.js' : isEnvDevelopment &amp;&amp; 'static/js/[name].chunk.js', // webpack uses `publicPath` to determine where the app is being served from. // It requires a trailing slash, or the file assets will get an incorrect path. // We inferred the "public path" (such as / or /my-project) from homepage. publicPath: paths.publicUrlOrPath, 执行 yarn build 进行打包，可以得到打包后的文件名。main.chunk.js 和 main.chunk.css 的 hash 值不同： 1234541.21 KB build/static/js/2.0b773d50.chunk.js1.4 KB build/static/js/3.113de9f7.chunk.js1.18 KB build/static/js/runtime-main.1f83336f.js603 B build/static/js/main.de68dd7b.chunk.js531 B build/static/css/main.8c8b27cf.chunk.css 再次打包，在内容无修改的情况下，打包后的文件名是不变的： 1234541.21 KB build/static/js/2.0b773d50.chunk.js1.4 KB build/static/js/3.113de9f7.chunk.js1.18 KB build/static/js/runtime-main.1f83336f.js603 B build/static/js/main.de68dd7b.chunk.js531 B build/static/css/main.8c8b27cf.chunk.css 随意修改一下 App.js 的内容，然后再次打包，main.xxx.chunk.js 的 hash 值变了，但是 main.xxx.chunk.css 的 hash 没有变化： 1234541.21 KB build/static/js/2.0b773d50.chunk.js1.4 KB build/static/js/3.113de9f7.chunk.js1.18 KB build/static/js/runtime-main.1f83336f.js604 B (+1 B) build/static/js/main.65d37fe9.chunk.js531 B build/static/css/main.8c8b27cf.chunk.css 将 App.js 的内容复原，再次打包，main.xxx.chunk.js 又与第 1 步、第 2 步的 hash 值相同了： 1234541.21 KB build/static/js/2.0b773d50.chunk.js1.4 KB build/static/js/3.113de9f7.chunk.js1.18 KB build/static/js/runtime-main.1f83336f.js603 B (-1 B) build/static/js/main.de68dd7b.chunk.js531 B build/static/css/main.8c8b27cf.chunk.css 随意修改一下 App.css 的内容，然后再次打包，main.xxx.chunk.css 的 hash 值变了，但是 main.xxx.chunk.js 的 hash 没有变化： 1234541.21 KB build/static/js/2.0b773d50.chunk.js1.4 KB build/static/js/3.113de9f7.chunk.js1.18 KB build/static/js/runtime-main.1f83336f.js603 B build/static/js/main.de68dd7b.chunk.js532 B (+1 B) build/static/css/main.3b619909.chunk.css 将 App.css 的内容复原，再次打包，main.xxx.chunk.css 又与第 1 步、第 2 步的 hash 值相同了： 1234541.21 KB build/static/js/2.0b773d50.chunk.js1.4 KB build/static/js/3.113de9f7.chunk.js1.18 KB build/static/js/runtime-main.1f83336f.js603 B (-1 B) build/static/js/main.de68dd7b.chunk.js531 B build/static/css/main.8c8b27cf.chunk.css 将 webpack.config.js 中的 contenthash 改为 chunkhash，重复上面 6 个步骤 执行 yarn build 进行打包，可以得到打包后的文件名。main.chunk.js 和 main.chunk.css 的 hash 值是相同的： 1234541.21 KB build/static/js/2.8308284b.chunk.js1.4 KB (+1 B) build/static/js/3.69da51f9.chunk.js1.18 KB build/static/js/runtime-main.5c8ad717.js604 B (+1 B) build/static/js/main.23b897ad.chunk.js531 B build/static/css/main.23b897ad.chunk.css 再次打包，在内容无修改的情况下，打包后的文件名是不变的： 1234541.21 KB build/static/js/2.8308284b.chunk.js1.4 KB build/static/js/3.69da51f9.chunk.js1.18 KB build/static/js/runtime-main.5c8ad717.js604 B build/static/js/main.23b897ad.chunk.js531 B build/static/css/main.23b897ad.chunk.css 随意修改一下 App.js 的内容，然后再次打包，main.xxx.chunk.js 和 main.xxx.chunk.css 的 hash 值都变了： 1234541.21 KB build/static/js/2.8308284b.chunk.js1.4 KB build/static/js/3.69da51f9.chunk.js1.18 KB build/static/js/runtime-main.5c8ad717.js602 B (-2 B) build/static/js/main.dedc4bbe.chunk.js529 B (-2 B) build/static/css/main.dedc4bbe.chunk.css 将 App.js 的内容复原，再次打包，main.xxx.chunk.js 和 main.xxx.chunk.css 又与第 1 步、第 2 步的 hash 值相同了： 1234541.21 KB build/static/js/2.8308284b.chunk.js1.4 KB build/static/js/3.69da51f9.chunk.js1.18 KB build/static/js/runtime-main.5c8ad717.js604 B (+2 B) build/static/js/main.23b897ad.chunk.js531 B (+2 B) build/static/css/main.23b897ad.chunk.css 随意修改一下 App.css 的内容，然后再次打包，main.xxx.chunk.js 和 main.xxx.chunk.css 的 hash 值都变了： 1234541.21 KB build/static/js/2.8308284b.chunk.js1.4 KB build/static/js/3.69da51f9.chunk.js1.18 KB build/static/js/runtime-main.5c8ad717.js603 B (-1 B) build/static/js/main.acc05875.chunk.js531 B build/static/css/main.acc05875.chunk.css 将 App.css 的内容复原，再次打包，main.xxx.chunk.css 又与第 1 步、第 2 步的 hash 值相同了： 1234541.21 KB build/static/js/2.8308284b.chunk.js1.4 KB build/static/js/3.69da51f9.chunk.js1.18 KB build/static/js/runtime-main.5c8ad717.js604 B (+1 B) build/static/js/main.23b897ad.chunk.js531 B build/static/css/main.23b897ad.chunk.css 将 webpack.config.js 中的 contenthash 改为 hash，重复上面 6 个步骤 执行 yarn build 进行打包，可以得到打包后的文件名。所有文件的 hash 值都是相同的： 1234541.21 KB (-2 B) build/static/js/2.c17725a0.chunk.js1.4 KB build/static/js/3.c17725a0.chunk.js1.16 KB (-16 B) build/static/js/runtime-main.c17725a0.js603 B (-1 B) build/static/js/main.c17725a0.chunk.js531 B build/static/css/main.c17725a0.chunk.css 再次打包，在内容无修改的情况下，打包后的文件名是不变的： 1234541.21 KB build/static/js/2.c17725a0.chunk.js1.4 KB build/static/js/3.c17725a0.chunk.js1.16 KB build/static/js/runtime-main.c17725a0.js603 B build/static/js/main.c17725a0.chunk.js531 B build/static/css/main.c17725a0.chunk.css 随意修改一下 App.js 的内容，然后再次打包，所有文件的 hash 值都变了： 1234541.21 KB (+2 B) build/static/js/2.375a482c.chunk.js1.4 KB (+1 B) build/static/js/3.375a482c.chunk.js1.16 KB (+1 B) build/static/js/runtime-main.375a482c.js604 B (+1 B) build/static/js/main.375a482c.chunk.js531 B build/static/css/main.375a482c.chunk.css 将 App.js 的内容复原，再次打包，所有文件的 hash 值又与第 1 步、第 2 步的 hash 值相同了： 1234541.21 KB (-2 B) build/static/js/2.c17725a0.chunk.js1.4 KB (-1 B) build/static/js/3.c17725a0.chunk.js1.16 KB (-1 B) build/static/js/runtime-main.c17725a0.js603 B (-1 B) build/static/js/main.c17725a0.chunk.js531 B build/static/css/main.c17725a0.chunk.css 随意修改一下 App.css 的内容，然后再次打包，所有文件的 hash 值都变了： 1234541.21 KB (-1 B) build/static/js/2.e437e80e.chunk.js1.4 KB (-1 B) build/static/js/3.e437e80e.chunk.js1.16 KB (-1 B) build/static/js/runtime-main.e437e80e.js602 B (-1 B) build/static/js/main.e437e80e.chunk.js531 B build/static/css/main.e437e80e.chunk.css 将 App.css 的内容复原，再次打包，所有文件的 hash 值又与第 1 步、第 2 步的 hash 值相同了： 1234541.21 KB (+1 B) build/static/js/2.c17725a0.chunk.js1.4 KB (+1 B) build/static/js/3.c17725a0.chunk.js1.16 KB (+1 B) build/static/js/runtime-main.c17725a0.js603 B (+1 B) build/static/js/main.c17725a0.chunk.js531 B build/static/css/main.c17725a0.chunk.css 总结一下 三者的区别： hash 计算与整个项目的构建相关； 整个项目公用一个 hash 值。 chunkhash 计算与同一 chunk 内容相关； 同一个 chunk 的 js 和 css 文件，公用一个 hash 值。任意一个文件内容改变，公用 hash 值改变。 contenthash 计算与文件内容本身相关。 当文件内容不变时，hash 值不变。 试验结论： 当代码内容不变的时候，contenthash和chunkhash都不会造成打包后文件hash值变化。 当代码变化时，contenthash比chunkhash引发变化的hash值更少。 所以，能用contenthash就用contenthash。 分析2拉下来的代码是没有变化的，但项目hash值确实变了，那会是打包机器不同造成的吗？ 经过试验发现： 打包的机器不同，打包后的hash值是不同的 同一台机器，在不同的文件位置，打包后的hash值也是不同的 但我这个问题是在同一个git ci上执行的打包，机器肯定是相同的。 分析3如果都没变化，那会不会是依赖的npm包变了呢？ 如果项目代码没变，但引用的 npm 包的版本变了，打包后的文件 hash 会变化吗？我们来动手试验一下，webpack 的 hash 设置为 contenthash。 在 package.json 中引入 query-string，但不 import yarn add query-string@6.13.8，执行打包： 1234541.22 KB build/static/js/2.0b773d50.chunk.chunkFilename.js1.41 KB build/static/js/3.113de9f7.chunk.chunkFilename.js1.19 KB build/static/js/runtime-main.b370ca9f.filename.js610 B build/static/js/main.de68dd7b.chunk.chunkFilename.js537 B build/static/css/main.8c8b27cf.chunk.chunFilename.css 只改变 package.json 中版本号，但不重新 install，打包后 hash 值不变。(废话，执行代码内容都没变) 1234541.22 KB build/static/js/2.0b773d50.chunk.chunkFilename.js1.41 KB build/static/js/3.113de9f7.chunk.chunkFilename.js1.19 KB build/static/js/runtime-main.b370ca9f.filename.js610 B build/static/js/main.de68dd7b.chunk.chunkFilename.js537 B build/static/css/main.8c8b27cf.chunk.chunFilename.css yarn add query-string@6.12.0，再次打包。(肯定不变啊，代码又没引用这个包) 1234541.22 KB build/static/js/2.0b773d50.chunk.chunkFilename.js1.41 KB build/static/js/3.113de9f7.chunk.chunkFilename.js1.19 KB build/static/js/runtime-main.b370ca9f.filename.js610 B build/static/js/main.de68dd7b.chunk.chunkFilename.js537 B build/static/css/main.8c8b27cf.chunk.chunFilename.css 在 App.js 中 import query-string，但不执行任何方法 yarn add query-string@6.13.8，执行打包： 1234543.79 KB build/static/js/2.1874ca7b.chunk.chunkFilename.js1.41 KB build/static/js/3.8361a48e.chunk.chunkFilename.js1.19 KB build/static/js/runtime-main.21632db2.filename.js613 B build/static/js/main.83b2031e.chunk.chunkFilename.js537 B build/static/css/main.8c8b27cf.chunk.chunFilename.css yarn add query-string@6.12.0，再次打包，2.xxx.chunk.chunkFilename.js 的 hash 值变了 1234543.66 KB build/static/js/2.02dac1eb.chunk.chunkFilename.js1.41 KB build/static/js/3.8361a48e.chunk.chunkFilename.js1.19 KB build/static/js/runtime-main.21632db2.filename.js613 B build/static/js/main.83b2031e.chunk.chunkFilename.js537 B build/static/css/main.8c8b27cf.chunk.chunFilename.css 在 App.js 中 import query-string，执行方法12const parsed = queryString.parse(window.location.search)console.log(parsed) yarn add query-string@6.13.8，执行打包： 1234543.78 KB build/static/js/2.5b8a76de.chunk.chunkFilename.js1.41 KB build/static/js/3.8361a48e.chunk.chunkFilename.js1.19 KB build/static/js/runtime-main.21632db2.filename.js653 B build/static/js/main.f3715165.chunk.chunkFilename.js537 B build/static/css/main.8c8b27cf.chunk.chunFilename.css yarn add query-string@6.12.0，再次打包 1234543.65 KB build/static/js/2.6d24736a.chunk.chunkFilename.js1.41 KB build/static/js/3.8361a48e.chunk.chunkFilename.js1.19 KB build/static/js/runtime-main.21632db2.filename.js653 B build/static/js/main.f3715165.chunk.chunkFilename.js537 B build/static/css/main.8c8b27cf.chunk.chunFilename.css 结论： 如果 npm 包只是在 package.json 中引入，但没有在代码里引入，相当于没有用这个 npm。该 npm 的版本变化不会引发打包后代码的 hash 值变化。（不用的包尽量删除） npm 包在代码里 import 引入后，该 npm 的版本变化会影响打包后的代码的 hash 值，即便只是 import，并没有真正使用。（这样冗余的代码，记得早点删除。可以使用 eslint 帮忙） 提交到 git 的代码，要带上 yarn.lock 或者 package-lock.json(二者选你常用的那个即可，不要一起提交到 git)，便于依赖包管理。 这样子，就不会引发一段时间后，明明代码没有改变，打包后的文件 hash 值却变了的问题了。 补充知识 chunk 是什么？ 存在依赖关系的模块，在打包时被封装为一个 chunk。webpack 会从入口文件开始检索，并将具有依赖关系的模块生成一棵依赖树，最终得到一个 chunk。如果 webpakc 定义了多个入口文件，就会得到多个 chunk 文件。 webpack 中 filename 和 chunkFilename 的区别 filename 指列在 entry 中，打包后输出的文件的名称。 chunkFilename 指未列在 entry 中，却又需要被打包出来的文件的名称。 改一下 webpack 的名字规则，让大家看起来更清晰： 1234541.22 KB build/static/js/2.0b773d50.chunk.chunkFilename.js1.41 KB build/static/js/3.113de9f7.chunk.chunkFilename.js1.19 KB build/static/js/runtime-main.b370ca9f.filename.js610 B build/static/js/main.de68dd7b.chunk.chunkFilename.js537 B build/static/css/main.8c8b27cf.chunk.chunFilename.css MiniCssExtractPlugin 本插件会将 CSS 提取到单独的文件中，为每个包含 CSS 的 JS 文件创建一个 CSS 文件，并且支持 CSS 和 SourceMaps 的按需加载。 SplitChunksPlugin 本插件自动拆分代码到不同的 chunk 文件中。参考官方文档 123456789默认情况下，它仅影响按需块，因为更改初始块会影响HTML文件应包含的脚本标签以运行项目。webpack将根据以下条件自动分割块：可以共享新块，或者模块来自node_modules文件夹新的块将大于20kb（在min + gz之前）按需加载块时并行请求的最大数量将小于或等于30初始页面加载时并行请求的最大数量将小于或等于30当试图满足最后两个条件时，最好使用较大的块。 runtimeChunk 单独分离出webpack的一些运行文件 代码可以在此处查看]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认识http referrer]]></title>
    <url>%2F%2Fblog%2F2020%2F11%2F%E8%AE%A4%E8%AF%86http-referrer.html</url>
    <content type="text"><![CDATA[Referer 是一个请求头参数，提供访问来源的信息前端通过document.referrer来获取，document.referrer 只读。 发送 referrer 的场景： 用户点击网页上的链接 用户发送表单 网页加载静态资源，比如加载图片、脚本、样式 referrer 值为空的场景：有时候，我们从请求头里看不到 referrer 值，document.referrer=&#39;&#39;。通常是在以下场景中会这样： 直接在浏览器中输入地址 使用 location.reload()刷新（location.href 或者 location.replace()刷新有信息） 在微信对话框中，点击进入微信自身浏览器 扫码进入微信或 QQ 的浏览器 简单说，就是在浏览器的新 tab 第一个打开页面的时候。 Referrer PolicyReferrer 有以下 8 种值，来控制是否显示 referrer，以及显示什么内容。 （1）no-referrer 不发送 Referer 字段。 （2）no-referrer-when-downgrade (大部分浏览器的默认行为) 如果从 HTTPS 网址链接到 HTTP 网址，不发送 Referer 字段，其他情况发送（包括 HTTP 网址链接到 HTTP 网址）。 （3）same-origin 链接到同源网址（协议+域名+端口 都相同）时发送，否则不发送。注意，https://foo.com 链接到http://foo.com也属于跨域。 （4）origin Referer 字段一律只发送源信息（协议+域名+端口），不管是否跨域。 （5）strict-origin 如果从 HTTPS 网址链接到 HTTP 网址，不发送 Referer 字段，其他情况只发送源信息。 （6）origin-when-cross-origin 同源时，发送完整的 Referer 字段，跨域时发送源信息。 （7）strict-origin-when-cross-origin (chrome的默认行为) 同源时，发送完整的 Referer 字段；跨域时，如果 HTTPS 网址链接到 HTTP 网址，不发送 Referer 字段，否则发送源信息。 （8）unsafe-url Referer 字段包含源信息、路径和查询字符串，不包含锚点、用户名和密码。 Referrer 策略可以通过以下方法声明： 通过隐式继承 通过 meta 标签，name 为 referrer 通过 http 请求头中的 Referrer-Policy 字段 通过&lt;a&gt;、&lt;area&gt;、&lt;img&gt;、&lt;iframe&gt;、&lt;link&gt;元素的referrerpolicy属性。 通过&lt;a&gt;、&lt;area&gt; &lt;link&gt;元素的rel=noreferrer属性 优先级依次加重例如：123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;meta name="referrer" content="unsafe-url" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a referrerpolicy="origin" href="https://f2estatic.youdao.com/handw/testReferrer2" &gt;跳转链接origin&lt;/a &gt; &lt;a referrerpolicy="origin-when-cross-origin" rel="noreferrer" href="https://f2estatic.youdao.com/handw/testReferrer2" &gt;跳转链接noreferrer&lt;/a &gt; &lt;a referrerpolicy="origin-when-cross-origin" rel="no-referrer" href="javascript:void(0)" onclick="handleClick()" &gt;跳转链接location.href&lt;/a &gt; &lt;script&gt; function handleClick() &#123; window.testsourceurl = window.location.href location.href = 'https://f2estatic.youdao.com/handw/testReferrer2' &#125; &lt;/script&gt; &lt;img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1604857952905&amp;di=b33cd45427b465a7abf938b7bf9ad800&amp;imgtype=0&amp;src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201503%2F07%2F20150307213740_PhyQE.png" alt="" /&gt; &lt;/body&gt;&lt;/html&gt; 第一个链接跳转后的 html 文件，请求头中的Referrer Policy: origin 第二个链接跳转后的 html 文件，请求头中的Referrer Policy: no-referrer(rel:noreferrer 的优先级高于 referrerpolicy) 除了特别指明 Referrer policy 的内容，页面中的 Referrer policy 取决于 meta 标签 第三个链接的跳转，用了 location.href，所以请求头中的Referrer Policy: unsafe-url 图片https://ydschool-video.nosdn.127.net/1597307153289title.png请求头中的Referrer Policy: unsafe-url 参考文档 http://www.ruanyifeng.com/blog/2019/06/http-referer.html https://www.zhangxinxu.com/wordpress/2017/02/js-page-url-document-referrer/ https://blog.lyz810.com/article/2016/08/referrer-policy-and-anti-leech/]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>html</tag>
        <tag>referrer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react16源码学习]]></title>
    <url>%2F%2Fblog%2F2020%2F10%2Freact16%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[基于这篇文章，自己实现了一个简单的react，记录笔记如下： 1. 定义 react.createElement(type, props, …children) 注：2020.10.25 使用最新的 create react app，自定义的 react.createElement 无效。 原因：package.json 中的”react-scripts”升级至”4.0.0”，本地启动时会调用 react-dev-jsx-runtime.development.js 中的 jsxWithValidation，而不是自定义的 createElement 方法。 解决方法：将 package.json 中的”react-scripts”降至 3.x.x，会直接调用自定义的 React.createElement 方法。 2. 定义 ReactDOM.render(vdom, container) 根据 vdom.type，创建真实 dom，document.createElement or document.createTextNode. 将 vdom.props 中除 children 之外的所有属性赋给刚创建的 dom 元素。 对于 children 进行递归调用 render 方法 container 调用 apppenChild 添加 vdom 3. requestIdleCallback 空闲调度逻辑ReactDOM.render 只是做了初始化的工作。剩下的任务是在 requestIdleCallback()中进行的，浏览器会自动在空闲的时候执行，完成 dom diff, 真实 dom 修改的工作 performUnitWork 每个单元执行以下工作内容： 生成新 dom 处理 fiber 返回下一个要操作的 fiber 1234567891011121314151617181920212223function performUnitWork(fiber) &#123; // 1. 为当前fiber创建dom if (!fiber.dom) &#123; fiber.dom = createDom(fiber) &#125; // 2. 为当前fiber的儿子元素（仅限这一代，不包含儿子的儿子）更新fiber信息，要跟上次渲染的状态做diff ... // 3. 找下一个调度任务 // 如果子元素存在，找子元素 if (fiber.child) &#123; return fiber.child &#125; // 子元素不存在，找兄弟元素； let nextFiber = fiber while (nextFiber) &#123; if (nextFiber.sibling) &#123; return nextFiber.sibling &#125; // 没有兄弟元素了，找父元素 nextFiber = nextFiber.parent &#125;&#125; 4. fiber 的数据结构，就是一个 jsx+一些链表属性的对象类型第一个fiber来源自ReactDOM.render(element, document.getElementById(&#39;root&#39;)) 1234567891011121314151617181920212223var element = &#123; type: '节点类型', props: &#123; ...props, // 真实dom属性 children: [], // jsxObject类型数组 &#125;,&#125;var firstFiber = &#123; dom: document.getElementById('root'), // 真实dom元素 props: &#123; children: [element], &#125;, type: 'div', // dom类型 parent: '父fiber', child: '第一个子fiber', sibling: '下一个兄弟fiber', prev: '上一次commit的rootFiber', effectTag: '更改状态，替换/删除/更新', hooks: [&#123; state: '', queue: [] &#125;]&#125; 所以fiber的数据结构如下： 12345678910var fiber = &#123; dom: DomObject, props: &#123; ...props, //真实dom属性 children: [jsxObject], &#125;, parent: '父fiber', child: '第一个子fiber', sibling: '下一个兄弟fiber',&#125; 5. commit 真实 dom 添加操作1234567891011function performUnitWork(fiber) &#123; // 1. add dom node if (!fiber.dom) &#123; createDom(fiber) &#125; // 如果在单元执行这里进行真实dom操作，会导致dom执行不连续。所以fiber调用可以空闲完成，但是dom操作必须一气呵成。 if (fiber.parent) &#123; fiber.parent.dom.appendChild(fiber.dom) &#125; ...&#125; 当所有 fiber 都执行完毕，就开始操作真实 dom 了。 1234567891011121314151617181920212223242526272829// 调度任务function workLoop(deadline) &#123; while (currentFiber &amp;&amp; deadline.timeRemaining() &gt; 1) &#123; currentFiber = performUnitWork(currentFiber) &#125; // 当前已经没有要调度的fiber了，那么就可以操作dom了 if (!currentFiber &amp;&amp; rootJsxNode) &#123; commitDom() &#125; requestIdleCallback(workLoop)&#125;function commitDom() &#123; // TODO add nodes to dom // 先添加第一个子节点的dom，在里面递归操作其他dom commitWork(rootJsxNode.child) // 根节点置为空，这样workLoop就停止工作了 rootJsxNode = null&#125;function commitWork(fiber) &#123; if (!fiber) &#123; return &#125; const domParent = fiber.parent.dom domParent.appendChild(fiber.dom) commitWork(fiber.child) commitWork(fiber.sibling)&#125; 6. 真实 dom 更新和删除操作（dom diff） performUnitWork 第二个任务处理 fiber记录上一次渲染后的状态，lastFiber，跟 curFiber 相同层级的虚拟 dom，一一做虚拟 dom diff 阶段，会比较 dom.type： 类型相同，则标记为更新 类型不同，curFiber 存在，则标记为替换（新增也属于替换） 类型不同，lastFiber 存在，则标记为删除。删除 fiber 同时要保存到一个 deletTasks 列表里，在 commitDom 阶段删掉。（因为新的 fiber 里没有保存要删除的 fiber 数据） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 2. 为当前fiber的儿子元素（仅限这一代，不包含儿子的儿子）更新fiber信息// 这里要做对比了，不是单纯创建fiber，而是要跟之前的状态做diffconst oldFiber = fiber?.prev?.childconst elements = fiber.props.children// 用于处理链接的nextlet prevSlibing = nulllet index = 0while (index &lt; elements.length || oldFiber) &#123; const ele = elements[index] let newFiber = null // 对比dom元素类型 const isSameType = oldFiber &amp;&amp; ele &amp;&amp; oldFiber.type === ele.type // 如果元素相同，则只改参数即可 if (isSameType) &#123; newFiber = &#123; ...oldFiber, props: ele.props, parent: fiber, prev: oldFiber, effectTag: 'UPDATE', &#125; &#125; // 新节点存在且元素类型不同，则替换fiber(其实这里就是新增) if (ele &amp;&amp; !isSameType) &#123; newFiber = &#123; type: ele.type, props: ele.props, parent: fiber, dom: null, base: null, effectTag: 'PLACEMENT', &#125; &#125; // 删除节点 if (oldFiber &amp;&amp; !isSameType) &#123; oldFiber.effectTag = 'DELETION' // 加到删除任务列表里 deleteTasks.push(oldFiber) &#125; // 这里相当于两个数组oldFiber和curFiber一一对比 // 第一个比较完了，开始比较第二个。如何跳到第二个？ // oldFiber = oldFiber.sibing // curFiber = elements[index++] if (oldFiber) &#123; oldFiber = oldFiber.sibling &#125; if (index === 0) &#123; // 第一个子元素，是父fiber的child fiber.child = newFiber &#125; else &#123; // 这里其实就是生成链表的套路，head.next = node, head = node prevSlibing.sibling = newFiber &#125; prevSlibing = newFiber index++&#125; commitDom 阶段 批量删除 deletTasks 12345678910function commitDom() &#123; // 递归删掉删除列表里的dom deleteTasks.forEach((deleteFiber) =&gt; commitWork(deleteFiber)) // 先添加第一个子节点的dom，在里面递归操作其他dom commitWork(rootJsxNode.child) // 保存最终的rootFiber，跟下次做dom diff用 lastRootFiber = rootJsxNode // 根节点置为空，这样workLoop就停止工作了 rootJsxNode = null&#125; commitWork 具体的 dom 操作 删除：把旧节点删掉，removeChild 替换：把新节点加进来，appendChild 更新：把原有节点旧属性和新属性对比，旧的去掉，换成新的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657function updateDom(dom, prevProps, props) &#123; // 旧参数遍历 Object.keys(prevProps) .filter((propName) =&gt; propName !== 'children') // 筛选出新props里没有的属性，去掉 .filter((propName) =&gt; !(propName in props)) .forEach((propName) =&gt; &#123; // 去掉事件处理 if (propName.startsWith('on')) &#123; dom.removeEventListener( propName.substring(2).toLowerCase(), prevProps[propName], false ) &#125; else &#123; // 属性置空 dom[propName] = '' &#125; &#125;) // 新参数遍历 Object.keys(props) .filter((propName) =&gt; propName !== 'children') .forEach((propName) =&gt; &#123; // 事件处理 if (propName.startsWith('on')) &#123; dom.addEventListener( propName.substring(2).toLowerCase(), prevProps[propName], false ) &#125; else &#123; dom[propName] = props[propName] &#125; &#125;) return dom&#125;function commitWork(fiber) &#123; if (!fiber) &#123; return &#125; const domParent = fiber.parent.dom // 删除节点 if (fiber.effectTag === 'DELETION') &#123; domParent.removeChild(fiber.dom) &#125; // 替换节点 if (fiber.effectTag === 'PLACEMENT' &amp;&amp; fiber.dom) &#123; // todo:替换不需要删掉旧fiber？答：在👆上面已经删除旧节点了 domParent.appendChild(fiber.dom) &#125; if (fiber.effectTag === 'UPDATE' &amp;&amp; fiber.dom) &#123; updateDom(fiber.dom, fiber.prev.props, fiber.props) &#125; commitWork(fiber.child) commitWork(fiber.sibling)&#125; 7. 函数组件1234567const App = (props) =&gt; ( &lt;div&gt; &lt;h1&gt;&#123;props.title&#125;&lt;/h1&gt; &lt;p&gt;源码学习&lt;/p&gt; &lt;a href="https://baidu.com" alt=""&gt;&lt;/a&gt; &lt;/div&gt;) 等价于 12345678910111213141516function createElement(type, props, ...children) &#123; delete props.__source delete props.__self return &#123; type, props: &#123; ...props, children: children.map((child) =&gt; &#123; return typeof child === 'object' ? child : createTextElement(child) &#125;), &#125;, &#125;&#125;const App = createElement(() =&gt; createElement('div', &#123;&#125;, ...children), &#123; title: 'hello world',&#125;) AppjsxObj.type = ()=&gt; createElement(&#39;div&#39;, {}, ...children)是一个 Function 函数组件有两个问题： 没有 dom 实例 children 来源于函数执行返回值，而不是 props.children 所以对于跟 dom 相关的问题，要处理 dom 相关问题。 fiber 处理阶段 12345678910111213141516// 处理函数组件的节点fiberfunction updateFunctionComponent(fiber) &#123; // 函数组件的rootFiber.type=()=&gt;&#123;&#125;，是一个function，无法createDom // if (!fiber.dom) &#123; // fiber.dom = createDom(fiber) // &#125; // 如果在单元执行这里进行真实dom操作，会导致dom执行不连续。所以fiber调用可以空闲完成，但是dom操作必须一气呵成。 // if (fiber.parent) &#123; // fiber.parent.dom.appendChild(fiber.dom) // &#125; // 2. 为当前fiber的儿子元素（仅限这一代，不包含儿子的儿子）更新fiber信息 // 这里要做对比了，不是单纯创建fiber，而是要跟之前的状态做diff // 函数fiber.props没有children属性。它的子元素等于： const elements = [fiber.type(fiber.props)] handleFiber(fiber, elements)&#125; dom 操作阶段 1234567891011121314151617181920212223242526272829303132function deleteDom(domParent, fiber) &#123; if (fiber.dom) &#123; domParent.removeChild(fiber.dom) &#125; else &#123; deleteDom(domParent, fiber.child) &#125;&#125;function commitWork(fiber) &#123; if (!fiber) &#123; return &#125; // function组件一定要层层找，才能找到父元素dom实例/子元素dom实例 let fiberParent = fiber.parent // 肯定能找到，因为顶级总会有一个ReactDOM.render(ele, $#root)。$#root是一个dom实例 while (!fiberParent.dom) &#123; fiberParent = fiberParent.parent &#125; const domParent = fiberParent.dom // 删除节点 if (fiber.effectTag === 'DELETION') &#123; deleteDom(domParent, fiber) &#125; // 替换节点 if (fiber.effectTag === 'PLACEMENT' &amp;&amp; fiber.dom) &#123; domParent.appendChild(fiber.dom) &#125; if (fiber.effectTag === 'UPDATE' &amp;&amp; fiber.dom) &#123; updateDom(fiber.dom, fiber.prev.props, fiber.props) &#125; commitWork(fiber.child) commitWork(fiber.sibling)&#125; 8. hooks1234567891011121314151617181920212223242526272829303132333435363738// 处理函数组件的节点fiberfunction updateFunctionComponent(fiber) &#123; // 每次都要重置hooks hookIndex = 0 currentFiber.hooks = [] ...&#125;function useState(init) &#123; const oldHooks = currentFiber?.prev?.hooks[hookIndex] const hook = &#123; state: oldHooks ? oldHooks.state : init, queue: [] &#125; const actionQueue = oldHooks ? oldHooks.queue : [] actionQueue.forEach(newstate =&gt; &#123; hook.state = newstate &#125;) const setState = newstate =&gt; &#123; hook.queue.push(newstate) // setState的时候触发调度任务。让workLoop再次工作 // 设置rootJsxNode，否则的话第一次调度结束，rootJsxNode一直为null，无法再次操作dom rootJsxNode = &#123; dom: lastRootFiber.dom, props: lastRootFiber.props, prev: lastRootFiber, &#125; currentFiber = rootJsxNode deleteTasks = [] &#125; // 这就直接push? // 答：fiber的每一次单元调用，都会重置currentFiber.hooks=[],hookIndex=0 // 也就是说，每次都会重置hooks。 // 所以设置const [state,setState] = useState(0),已经设置state为const类型了，下次setState()还可以更新state的值。因为每次都是不同的值 currentFiber.hooks.push(hook) hookIndex++ return [hook.state, setState]&#125; 问题 1：const [st, setSt] = useState(1), st 是 const 类型，为什么 setSt(2)的时候可以把 st 变成 2 呢？ 答：看代码，每一次 useState 执行，都是生成一个新的参数和 set 方法 问题 2：为什么 setSt，会重新引发 render 答：setSt 时，会重新配置 rootFiber，进而引发 workLoop 调度 123456789101112const setState = (newstate) =&gt; &#123; hook.queue.push(newstate) // setState的时候触发调度任务。让workLoop再次工作 // 设置rootJsxNode，否则的话第一次调度结束，rootJsxNode一直为null，无法再次操作dom rootJsxNode = &#123; dom: lastRootFiber.dom, props: lastRootFiber.props, prev: lastRootFiber, &#125; currentFiber = rootJsxNode deleteTasks = []&#125; 问题 3：setSt 后的，程序执行过程 答：setSt 后，设置 rootFiber -&gt; workLoop() -&gt; performUnitWork(fiber) -&gt; updateFunctionComponent(fiber) -&gt; fiber.type(fiber.props) -&gt; 函数组件从头执行一遍 -&gt; useState() -&gt; hooks.st = newstate -&gt; handleFiber(fiber, elements) -&gt; dom diff -&gt; dom 操作]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>源码</tag>
        <tag>react</tag>
        <tag>react hook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react组件全局变量写在Component前面和用Ref的区别]]></title>
    <url>%2F%2Fblog%2F2020%2F10%2Freact%E7%BB%84%E4%BB%B6%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%86%99%E5%9C%A8Component%E5%89%8D%E9%9D%A2%E5%92%8C%E7%94%A8Ref%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
    <content type="text"><![CDATA[在 react hook 中，因为闭包陷阱的问题，我们不能使用 useState 来进行处理。比如下面这段代码，不管怎么setCount，console输出的还是最初的值。 123456789101112131415161718192021import React, &#123;useEffect, useState&#125; from 'react'const ClosureExample = (&#123;index&#125;) =&gt; &#123; const [count, setCount] = useState(0) useEffect(() =&gt; &#123; setInterval(() =&gt; &#123; console.log(count) &#125;, 1000) &#125;, []) return ( &lt;button onClick=&#123;() =&gt; &#123; setCount(index) console.log(`已点击$&#123;index&#125;`) &#125;&#125; &gt;&#123;`点击闭包陷阱$&#123;index&#125;`&#125;&lt;/button&gt; )&#125;export default ClosureExample 解决思路就是用全局变量来处理，可以使用两种方式来处理： useRef，作为组件实例的变量，保证获取到的数据肯定是最新的 在组件前定义一个类似 global 的变量 但这就引发了另外一个问题，既然这两种方式都能解决问题，那两种方式有什么区别呢？ useRef 是定义在实例基础上的，如果代码中有多个相同的组件，每个组件的 ref 只跟组件本身有关，跟其他组件的 ref 没有关系。 组件前定义的 global 变量，是属于全局的。如果代码中有多个相同的组件，那这个 global 变量在全局是同一个，他们会互相影响。 Talk is cheap, show the code. 点击上面代码查看，用 ref 的组件，click 时 console 的内容是不同的。而用组件前变量的组件，click 时 console 的内容都是最后出现的那个组件的值。 你，学会了吗？]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>知识点</tag>
        <tag>备忘</tag>
        <tag>react</tag>
        <tag>react hook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试系列:防抖和节流]]></title>
    <url>%2F%2Fblog%2F2020%2F09%2F%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97-%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81.html</url>
    <content type="text"><![CDATA[今天听到关于防抖和节流最容易理解的解释，记录一下。 防抖 就是发动技能的吟唱（战术前摇），需要一定时间，而且会被打断。打断之后只能重新吟唱。所以手写出来就是： 12345678910111213function debounce(fn, time) &#123; let timer = null return function() &#123; // 如果被打断，重新吟唱 if (timer) &#123; clearTimeout(timer) &#125; timer = setTimeout(fn, time) &#125;&#125;const click = debounce(()=&gt;&#123;console.log(1)&#125;, 1000)click() 节流 就是技能发动后的冷却时间（cd），技能发动一段时间内，不能再次发动，只能等cd结束才能再次发动。所以手写出来就是： 1234567891011121314function throttle(fn, time) &#123; let timer = null return function() &#123; // 冷却结束后，才能再次发动 if(!timer) &#123; timer = setTimeout(()=&gt;&#123; // 没处理带参函数 fn() // 防止内存泄露 timer = null &#125;, time) &#125; &#125;&#125; 带参函数情况：12345678910111213141516function throttle(fn, time) &#123; let timer = null return function() &#123; let _this = this let _args = arguments // 冷却结束后，才能再次发动 if(!timer) &#123; timer = setTimeout(()=&gt;&#123; // 带参函数 fn.apply(_this, _args) // 防止内存泄露 timer = null &#125;, time) &#125; &#125;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从堆栈角度讲闭包]]></title>
    <url>%2F%2Fblog%2F2020%2F08%2F%E4%BB%8E%E5%A0%86%E6%A0%88%E8%A7%92%E5%BA%A6%E8%AE%B2%E9%97%AD%E5%8C%85.html</url>
    <content type="text"><![CDATA[看了极客时间的《浏览器工作原理与实践》，讲的真不错，记一下笔记。 内存空间要理解 JavaScript 在运行过程中数据是如何存储的，你就得先搞清楚其存储空间的种类。 在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是代码空间、栈空间和堆空间。 其中的代码空间主要是存储可执行代码的，这个我们后面再做介绍，今天主要来说说栈空间和堆空间。 原始类型的数据值都是直接保存在“栈”中的，引用类型的值是存放在“堆”中的。不过你也许会好奇，为什么一定要分“堆”和“栈”两个存储空间呢？所有数据直接存放在“栈”中不就可以了吗？ 通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，堆空间很大，能存放很多大的数据，不过缺点是分配内存和回收内存都会占用一定的时间。 闭包12345678910111213141516171819function foo() &#123; var myName = " 极客时间 " let test1 = 1 const test2 = 2 var innerBar = &#123; setName:function(newName)&#123; myName = newName &#125;, getName:function()&#123; console.log(test1) return myName &#125; &#125; return innerBar&#125;var bar = foo()bar.setName(" 极客邦 ")bar.getName()console.log(bar.getName()) 我们介绍了当 foo 函数的执行上下文销毁时，由于 foo 函数产生了闭包，所以变量 myName 和 test1 并没有被销毁，而是保存在内存中，那么应该如何解释这个现象呢？ 要解释这个现象，我们就得站在内存模型的角度来分析这段代码的执行流程。 当 JavaScript 引擎执行到 foo 函数时，首先会编译，并创建一个空执行上下文。 在编译过程中，遇到内部函数 setName，JavaScript 引擎还要对内部函数做一次快速的词法扫描，发现该内部函数引用了 foo 函数中的 myName 变量，由于是内部函数引用了外部函数的变量，所以 JavaScript 引擎判断这是一个闭包，于是在堆空间创建换一个“closure(foo)”的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存 myName 变量。 接着继续扫描到 getName 方法时，发现该函数内部还引用变量 test1，于是 JavaScript 引擎又将 test1 添加到“closure(foo)”对象中。这时候堆中的“closure(foo)”对象中就包含了 myName 和 test1 两个变量了。 由于 test2 并没有被内部函数引用，所以 test2 依然保存在调用栈中。 从上图你可以清晰地看出，当执行到 foo 函数时，闭包就产生了；当 foo 函数执行结束之后，返回的 getName 和 setName 方法都引用“clourse(foo)”对象，所以即使 foo 函数退出了，“clourse(foo)”依然被其内部的 getName 和 setName 方法引用。所以在下次调用bar.setName或者bar.getName时，创建的执行上下文中就包含了“clourse(foo)”。 总的来说，产生闭包的核心有两步：第一步是需要预扫描内部函数；第二步是把内部函数引用的外部变量保存到堆中。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>知识点</tag>
        <tag>闭包</tag>
        <tag>堆栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[antd select选择器使用]]></title>
    <url>%2F%2Fblog%2F2020%2F06%2Fantd-select%E9%80%89%E6%8B%A9%E5%99%A8%E4%BD%BF%E7%94%A8.html</url>
    <content type="text"><![CDATA[之前一直使用select组件，却没得要领，每次写起来都贼复杂。原来人家有这么多好的属性你不会用啊。给你你不中用啊[手动刘华强] 点击链接查看，就是这么简单实用123456789101112131415161718192021222324252627const &#123; Select &#125; = antd;const &#123; Option &#125; = Select;const children = [];for (let i = 10; i &lt; 36; i++) &#123; children.push(&lt;Option key=&#123;i&#125; value=&#123;i&#125;&gt;&#123;i.toString(36) &#125;:&#123;i&#125;&lt;/Option&gt;);&#125;function handleChange(value) &#123; console.log(`selected $&#123;value&#125;`);&#125;ReactDOM.render( &lt;Select showArrow showSearch style=&#123;&#123; width: '100%' &#125;&#125; placeholder="Please select" optionFilterProp="children" //设置为 children 表示对内嵌内容进行搜索 onChange=&#123;handleChange&#125; defaultValue=&#123;11&#125; &gt; &#123;children&#125; &lt;/Select&gt;, mountNode,);]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>antd</tag>
        <tag>javascript</tag>
        <tag>备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[object-fit-polyfill解析]]></title>
    <url>%2F%2Fblog%2F2020%2F04%2Fobject-fit-polyfill%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"><![CDATA[最近在做一个视频背景的项目，用到了object-fit这个 css 属性。但是在万恶的 ie 浏览器上遇到了兼容性问题，ie 不支持该属性，怎么办呢，在万能的 github 上找到了 polyfill 的方法，看完源码把思路记录一下。 首先看一下，object-fit这个属性是干嘛的使用 object-position 属性来切换&quot;被替换元素&quot;(如video,img,iframe)的内容对象在填充框里展示多少内容。 参数取值 contain 保留原始宽高比，展示全内容，填充框中剩余内容用空白填充 cover 保留原始宽高比，不展示全内容，溢出就隐藏 fill 不保留宽高比，展示全内容，拉伸塞满填充框 none 不展示全内容，保存原始尺寸，溢出就隐藏。和 cover 的区别在于，cover 的尺寸不一定是原始的 scale-down 取 cotain 和 none 中尺寸小的一个 浏览器兼容性 只有ie不支持 object-fit-polyfill github 上还有几个其他的 polyfill，但只有这个支持 video 这里作者针对 object-fit 的各个参数都做了 polyfill，在 src/objectFitPolyfill.js 中 同时提供了最基础版本的 polyfill 文件src/objectFitPolyfill.basic.js，默认支持 object-fit: cover 和 object-position: 50% 50%. 我们就看一下这个源码是怎么实现的： 上来先判断是否支持objectFit，不支持才需要polyfill。而且判断了是否是edge浏览器，edge16以上只原生实现了img标签的object-fit支持，其他标签还得用polyfill。 123456789101112131415161718// if the page is being rendered on the server, don't continueif (typeof window === 'undefined') return;// Workaround for Edge 16+, which only implemented object-fit for &lt;img&gt; tags// TODO: Keep an eye on Edge to determine which version has full final supportvar edgeVersion = window.navigator.userAgent.match(/Edge\/(\d&#123;2&#125;)\./);var edgePartialSupport = edgeVersion ? parseInt(edgeVersion[1], 10) &gt;= 16 : false;// If the browser does support object-fit, we don't need to continuevar hasSupport = 'objectFit' in document.documentElement.style !== false;if (hasSupport &amp;&amp; !edgePartialSupport) &#123; window.objectFitPolyfill = function() &#123; return false; &#125;; return;&#125; checkParentContainer 设置父节点样式 checkParentContainer 设置要polyfill的标签的默认样式 objectFit 重点来喽 下面以video标签设置polyfill举例分析源码1234567891011121314151617181920212223242526272829303132333435var objectFit = function($media) &#123; // If necessary, make the parent container work with absolutely positioned elements var $container = $media.parentNode; checkParentContainer($container); // Check for any pre-set CSS which could mess up image calculations checkMediaProperties($media); // Mathematically figure out which side needs covering, and add CSS positioning &amp; centering $media.style.position = 'absolute'; $media.style.height = '100%'; $media.style.width = 'auto'; // 参考demo:http://f2estatic.youdao.com/handw/object-fit-polyfill.html // 1.在设置video标签之前，先设置video标签高度100%，这时候video标签以原始宽高比展示在页面中，未铺满屏幕，只占据左侧。 if ($media.clientWidth &gt; $container.clientWidth) &#123; // 2.如果video比父节点宽 $media.style.top = '0'; $media.style.marginTop = '0'; // 3.设置左移50%，这样子视频只能看见一半(见下图，红框为可见区域) $media.style.left = '50%'; // 4.再设置负的margin-left /* 对于绝对定位元素，负margin会基于其绝对定位坐标再偏移， 唯有的缺点就是你必须知道这个觉得定位元素宽度的和高度才能并设置负margin值使其居中浏览器窗口， */ $media.style.marginLeft = $media.clientWidth / -2 + 'px'; &#125; else &#123; $media.style.width = '100%'; $media.style.height = 'auto'; $media.style.left = '0'; $media.style.marginLeft = '0'; $media.style.top = '50%'; $media.style.marginTop = $media.clientHeight / -2 + 'px'; &#125;&#125;;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>知识点</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react hook使用感受]]></title>
    <url>%2F%2Fblog%2F2020%2F03%2Freact-hook%E4%BD%BF%E7%94%A8%E6%84%9F%E5%8F%97.html</url>
    <content type="text"><![CDATA[大牛文章推荐从开始用 react hook 到现在有一段时间了，一直没太理解 hook 的好处在哪里，感觉就是另外一种写 class 的方式，所以仍然按照写 class 的思路在写 hook。 直到最近看了蚂蚁金服的这篇技术分析，有了一种醍醐灌顶的感觉。原来 hook 应该这么用啊，确实简单多了。文章推荐给大家。 setState 和 useState本来写到这就结束了，恰巧又遇到了一个 hook 相关的问题，感觉也很不错，分享给大家。 大家都知道 setState 是个异步的过程，setState 结束后立马获取 state 数据可能还是更新之前的。解决方法就是给 setState 传第二个参数，该参数是个函数，里面可以拿到更新后的 state。比如这种： 123456789101112131415161718192021handleChangeShare (type, value) &#123; this.setState( &#123; shareData: &#123; ...this.state.shareData, [type]: value &#125; &#125;, () =&gt; &#123; const &#123;shareDataFromServer, shareData&#125; = this.state const &#123; serverTitle, serverContent &#125; = shareDataFromServer const &#123; title: localTitle, content: localContent &#125; = shareData // 拿到更新后的shareData数据，跟另一个数据做比较 if (serverTitle === localTitle &amp;&amp; serverContent === localContent) &#123; this.setState(&#123;shareBtnDisable: true&#125;) &#125; else &#123; this.setState(&#123;shareBtnDisable: false&#125;) &#125; &#125; )&#125; 当我们用 useState 来改写时怎么处理呢，useState 也是个异步的过程，但是没有第二参数。怎么解决呢？ 答案是用 useEffect，废话少说上代码： 12345678910111213141516useEffect(() =&gt; &#123; const &#123;serverTitle, serverContent&#125; = shareDataFromServer const &#123;title: localTitle, content: localContent&#125; = shareData if (serverTitle === localTitle &amp;&amp; serverContent === localContent) &#123; setShareBtnDisable(true) &#125; else &#123; setShareBtnDisable(false) &#125;&#125;, [shareData])const handleChangeShare = (shareType, value) =&gt; &#123; setShareData(prevShareData =&gt; (&#123; ...prevShareData, [shareType]: value &#125;))&#125; 是不是很简单啊，转换一下固有思路，不要用旧的思路来写 react hook。之前一直把 useEffect 当成 componentDidMount 或者 componentDidUpdate 来用，只用来操作 dom 或处理网络请求，看来是把 useEffect 小瞧了。 react 的官方文档里写的很详细，有时间还是要仔细看看。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>react</tag>
        <tag>react hook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[比iframe和dangerouslySetInnerHTML更好用的插入其他网站的方式]]></title>
    <url>%2F%2Fblog%2F2020%2F02%2F%E6%AF%94iframe%E5%92%8CdangerouslySetInnerHTML%E6%9B%B4%E5%A5%BD%E7%94%A8%E7%9A%84%E6%8F%92%E5%85%A5%E5%85%B6%E4%BB%96%E7%BD%91%E7%AB%99%E7%9A%84%E6%96%B9%E5%BC%8F.html</url>
    <content type="text"><![CDATA[最近的项目里，有这样一个需求： 在 A 页面里插入 B 页面的内容，且要求： B 的内容格式不能乱 A 的内容和 B 的内容要无缝衔接，像一个页面一样 B 页面里有很多script标签，功能要正常可用。 B 页面不会为了适配 A 页面，去做改动优化 方案 1：iframe要在一个页面插入另一个页面的内容，首先想到的方案肯定是 iframe，只要简单填一个 src 就 ok 了。但存在三个问题： 高度问题 如果给 iframe 设置了宽高，那么 B 页面的内容只能在 iframe 里滚动显示。这与需求 2 不符。如果要让 iframe 的宽高由内容决定，应该设置如下： 1234567891011121314151617181920212223const iframeAutoHeight = iframe =&gt; &#123; if ( navigator.userAgent.indexOf('MSIE') &gt; 0 || navigator.userAgent.indexOf('rv:11') &gt; 0 || navigator.userAgent.indexOf('Firefox') &gt; 0 ) &#123; iframe.height = iframe.contentWindow.document.body.scrollHeight &#125; else &#123; iframe.height = iframe.contentWindow.document.documentElement.scrollHeight &#125;&#125;useEffect(() =&gt; &#123; const iframe = document.getElementById('xFrame') if (iframe.attachEvent) &#123; iframe.attachEvent('onload', () =&gt; &#123; iframeAutoHeight(iframe) &#125;) &#125; else &#123; iframe.onload = () =&gt; &#123; iframeAutoHeight(iframe) &#125; &#125;&#125;) 链接跳转问题 如果 B 页面里有 a 标签之类的跳转，使用 iframe 的方式，只能在 iframe 里跳转，而不能在整个页面里进行跳转。 如果只是少数几个明确的跳转方式， 比如 a 标签，可以改target=&#39;_top&#39; location.href 跳转，改为 123&lt;script language="JavaScript"&gt; if (window != top) top.location.href = location.href;&lt;/script&gt; 但因为需求 4 以及 B 页面存在大量我们无法预知的跳转方式，这些无法满足。 跨域问题 这个是更大的问题，如果 A、B 两个页面存在跨域问题，那么 A 页面处理问题 1，2 的方案就不可用 😭 方案 2：react 的 dangerouslySetInnerHTML让我们靠谱的后端同学，在接口返回数据里直接把 B 页面的内容返回给 A，然后在 A 里使用 dangerouslySetInnerHTML，但这样子可以满足需求 1，2，4，但是需求 3 出问题了。 因为 dangerouslySetInnerHTML 无法解析出里面的 script 标签，并进行执行。dangerouslySetInnerHTML 其实就是 react 给我们写的一个dom.innerHMTL = xxx的语法糖，innerHTML 是不会执行 script 标签里的内容的。 方案 3：createContextualFragment + appendChild仍然让我们靠谱的后端同学，把 B 页面的内容用接口的形式发给我们，然后 12345678910111213141516import React, &#123;useEffect, useRef&#125; from 'react'function DangerouslySetHtmlContent(props) &#123; const &#123;html&#125; = props const divRef = useRef(null) useEffect(() =&gt; &#123; const slotHtml = document.createRange().createContextualFragment(html) // Create a 'tiny' document and parse the html string divRef.current.innerHTML = '' // Clear the container divRef.current.appendChild(slotHtml) // Append the new content &#125;, [html]) return &lt;div ref=&#123;divRef&#125;&gt;&lt;/div&gt;&#125;export default DangerouslySetHtmlContent 完美！ 参考资料 https://github.com/christo-pr/dangerously-set-html-content/blob/master/src/index.js https://blog.csdn.net/qq_33556185/article/details/50669978 https://juejin.im/entry/58cb529244d90400682e6012]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>react</tag>
        <tag>iframe</tag>
        <tag>dangerouslySetInnerHTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020年的魔幻开局]]></title>
    <url>%2F%2Fblog%2F2020%2F02%2F2020%E5%B9%B4%E7%9A%84%E9%AD%94%E5%B9%BB%E5%BC%80%E5%B1%80.html</url>
    <content type="text"><![CDATA[王兴说“2019是过去十年最差的一年，却是未来十年最好的一年”。好家伙，这2020的好坏差距也太大了吧。2020已经开始一个半月了，很多人经历了一辈子都难得一见的第一次。 2020的开局美国击毙伊朗大员，伊朗击落自家飞机，澳大利亚发大火，非洲闹蝗灾等等等等 新型冠状病毒2019因为新冠病毒的影响，全中国人民都过了一个特殊的春节。没有拜年，没有走亲访友，没有出门旅游，没有各种high，老老实实宅在家里。 这段时间大家的情绪起伏都很大，电视里手机里充斥着各种大的新闻，新冠病毒的死亡人数、传播速度，出丑的武汉市湖北省的各路官员，红十字会，鄂A车牌，武汉病毒所，病毒所所长的夫妻档八卦，双黄连，cdc高福院士，武汉生鲜市场，钟南山院士，方舱医院，韩红基金会，各省市、农村封城，火神山、雷神山医院，各省市出色的官员，北京市的疫情，《传染病》电影，抢购口罩等等等等的神奇，统统发生在我们脚底下这片神州大陆。 希望疫情尽快过去，希望我们的祖国尽量恢复过来。 科比1.27早上5点，我醒了，本来想看一下新冠肺炎的新闻，却再也睡不着了。万万没想到，科比居然意外去世了。真的是想破脑袋也想不到的事情。 直到现在都难以置信，真的不想承认这件事是真的。这件事让人难以接受的原因： 科比正值壮年，41岁退役才仅仅4年，身体健康亿万富翁，谁能想到死于直升飞机事故 大家都幻想着科比退役后的精彩生活，跟谁斗嘴，又将在哪里叱咤风云 乔丹都活得好好的，甚至拉塞尔前辈都活得好好的，科比怎么没了。。。 大家能接受的死亡，是垂垂老矣的科比在家人的陪伴下安详的去世了，如同大家都能接受金庸先生、斯坦李的离世一样 对于我的生活影响这可能是难得的，我和老婆还有年糕宝贝，24小时不离不弃的宅在家里的1个月（到目前为止），如果没有这次疫情，可能这辈子没都这经历了。哦对，陪老婆坐月子的时候也有一次，但那次我们会下楼放放风。这次，真的，年糕已经半个多月没出去了。好好珍惜这段时光，等他长大了讲给他听，视频放给他看，一辈子的回忆。 这段时间也是消费最低的时候，除了买菜，也没别的消费了。就算是买菜，也基本上在网上买。刚开始的时候，我还去小区旁边的生鲜超市买了两回儿菜，现在就直接app下单了，直接小区门口拿。 这段时间也是自己做饭最多的时候，毕竟一天三顿都得在家吃，而且外卖都不敢点。天天变着花的想着怎么做饭，厨艺都有所长进。下厨房app在春节当晚当机了，没想到的人流量。 最开始，不管是超市还是app里，菜都不是全的，平时没感觉菜也会买不到，但非常时期真的会买不到。就比如说切片面包，我跑了好几个便利店才买到。便利店里的货架，好多也都空了。晚上出来逛的时候，黑黑的天，空荡的街区，有一种世界末日的感觉。之后货物是慢慢的供应上了，各种物资（除了口罩酒精消毒相关）也都慢慢不缺了，国家生产力毕竟摆在那里。 对快递来说，这次疫情里最棒的还是京东（我只说北京）。平时被大家诟病的自建仓储自营快递员，这次得到了充分的表现机会。京东到家，还是一如既往的快，可能比之前要稍微慢一点，但基本自营能做到次日达。淘宝、严选、考拉这些基本歇菜了，买东西就且等着吧。 远程办公难得的跟国际接轨的机会，在延长到2.3号的春节假期结束之后，开始了我们的远程办公的日子。没想到的第一天，居然卡在了vpn的配置上。辛苦公司的it同学了，之前只有少量技术同事在用的vpn，现在全公司都在用，原先的服务挂了，只有加机器重新配置。 远程办公对于技术开发而言，基本没啥影响，本来在公司就是一个人敲敲打打。现在更好，还少了有人过来打扰你写代码，可以愉快的写个痛苦。同时问题也来了，以前走两步就可以过去沟通的问题，现在im软件上聊不明白，聊不及时，一着急想语音想打电话，可能那边都没看到。 沟通是个大问题，debug的难度上来了。有些人过来找你，但问题也描述不清楚，过去可以直接过去他电脑那看怎么回事，现在想复现一下现场都不太容易。 这些都还好，最难的双职工家庭加一个孩子，还没有老人，这怎么工作。只有把能一个人干的活，放到深更半夜无人时再做。 对疫情的思考从各处看到的新闻，普遍觉着好的情况，疫情会在3月底结束，如果不好可能都要拖到5月份去。 这样的情况下，对中国的经济是打击很大的。很多小微企业无法开工，没有收入，可能就面临死掉的危险。对于很多普通老百姓来说，可能日子会过的很苦，减薪都是轻的，甚至会被裁员没有收入，这将会是一段很艰苦的时间。 对于一些线上领域，比如游戏、在线教育、内容行业等，虽然不好听，但是个好的机会，一方面可以不太受影响的发展，甚至获客成本都在下降；另一方面，受资金链的影响，发展前景不好只是想捉风口蹭热度的公司会被淘汰，行业重新洗牌，活下来的都是有实力发展的。 总体来说，这次对中国的经济发展会产生巨大的影响。之前我们就在打贸易战、在进行产能升级换代，再加上疫情的影响，在短时间内中国经济发展增速变慢，老百姓要勒紧裤腰带过日子。看国家怎么处理这个问题，千万不要跟08年一样，再来个四万亿，那个真的对老百姓没啥用，反而会让富的更富穷的更穷。 中国人最能坚持的就是‘忍’。我们这代人比较幸福，基本上没怎么吃过苦。对于上一辈的人来说，现在即不久的将来出现的困难，他们都经历过，没啥大不了的。而对于我们这代人，甚至更年期的00后来说，会是人生难得的一次经历。 加油，我的祖国！加油，伟大的中国人民！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-12前端月报]]></title>
    <url>%2F%2Fblog%2F2019%2F12%2F2019-12%E5%89%8D%E7%AB%AF%E6%9C%88%E6%8A%A5.html</url>
    <content type="text"><![CDATA[新闻 Chrome 79发布 新特性: Web XR可以使用WebXR Device API为智能手机和头戴式显示器创建沉浸式体验 Wake Lock API(实验性) 请求页面锁定，防止屏幕变暗或启动屏幕保护程序 调用navigator.wakeLock.request() 进入全屏、最小化、窗口切换时，会自动释放锁 rendersubtree属性，没太懂有时候，不希望部分DOM立即呈现。例如，滚动条中包含大量内容，或者在任何给定时间仅显示部分内容的选项卡式UI。 新rendersubtree属性告诉浏览器可以跳过渲染该子树。这使浏览器可以花更多时间处理其余页面，从而提高性能。 当rendersubtree设置为时invisible，不对元素的内容进行绘制或命中测试，从而可以进行渲染优化。 将rendersubtree改为activatable，可以通过删除invisible属性并呈现内容来使内容可见 标签冻结 卸载所有超过五分钟不活动的选项卡。这样可以为其他选项卡或其他本地运行的应用程序释放CPU和RAM系统资源。 当用户再次切换回该标签页时，则会自动刷新重载 会排除掉一些特殊的情景，比如说如果非活动标签页正在播放音视频内容，那么标签页即便是超过五分钟没有活动也不会被释放资源，这样避免在收听内容时出现中断 默认不开启，可以在 chrome://flags 中找到 #proactive-tab-freeze 进行开启 密码检查 Google会获取您所有与Chrome同步的密码，并检查是否有其他在线服务导致其泄露 此前，密码检查仅作为单独的Chrome扩展程序或Google Web仪表板中的部分提供。从Chrome 79开始，Password Checkup已集成到Chrome本身。要使用它，Chrome用户必须在Chrome中登录其Google帐户 尚未在 Chrome 79 全量上线，即便在 chrome://flags 中开启了相关的功能标签（chrome://flags/#password-leak-detection）选项也无法直接激活相关设置，因此我们推测这可能是一项服务器端更新 实时将不良网站列入黑名单 此前，Chrome每30分钟下载一次已知不良网站的列表。但是，Google表示，近几个月来，黑客利用这一30分钟的延迟，以更快的速度改变站点和域 Google表示Chrome将在“同步和Google服务”部分提供一个新选项，使用户能够实时扫描不良站点。 禁止加载HTTPS“混合内容” 从今年12月开始测试的 Chrome 79开始，Chrome将会逐步阻止所有混合内容。到2020年1月，Chrome 80会将所有混合音频和视频资源自动升级为HTTPS，如果无法通过HTTPS加载，则将自动被阻止。最终，在2020年2月，Chrome 81将所有混合图像、音频与视频自动升级为HTTPS，并且阻止那些无法通过HTTPS加载的图像。 后退按钮缓存(实验性) 此功能的作用是为“后退和前进” Chrome按钮创建特殊的缓存。如果用户在浏览历史记录中前进或后退，则将从此缓存加载页面，而不是从头开始加载。 还有个小插曲： Android平台(79.0.3945.79)使用webview框架搭建的app遭遇数据清空问题 google调整了缓存位置，却没有同步迁移旧数据，导致无法访问 倏忽一年：回顾点评前端 2019 重大事件、趋势 完全支持 iOS 13 暗色模式 改进的 Add-to-App 体验将 Flutter 集成到已有 Android 或 iOS App 的能力 Dart 2.7 提供了 Web 支持（beta 版）和 macOS 支持（alpha 版） 技术 react hook专题 How to fetch data with React Hooks? React Hooks 在蚂蚁金服的实践 如何去合理使用 React hook？ 使用 React Hooks 声明 setInterval 如何使用 docker 部署前端应用 Kubernetes 儿童插图指南 用可视化的方式，学习 JavaScript 引擎 html解析器，下载script二进制字节流 字节流解码器，字节流 -&gt; js源码 解析器parser，源码 -&gt; AST 解释器interpreter，AST -&gt; Bytecode 编译器compiler，Bytecode -&gt; machine code(其实是汇编语言) 解密 VS Code 断点调试的原理 文章 我们是如何将网站加载时间减少24%的？ 中文翻译 优化原因： 良好的用户体验——即加载时间更短（且互动性更好）和使用时的愉悦感 ; SEO—— 我们的流量严重依赖谷歌搜索，而且你也许知道谷歌比较青睐性能良好的网站（谷歌甚至在搜索控制台中引入了速度报告）。 常用的性能优化方法： 静态资源使用 CDN 并配置合理的缓存时间； 优化图片尺寸和格式； 使用 Gzip 或 Brotli 压缩； 减少非关键的 JS 和 CSS 代码的大小。 他们还用了： 引入了 react-window 来 每次渲染 10 个列表项，而不是 250 个 针对 JSON 数据使用 rel=&quot;preload&quot; 在服务端实现超简单的缓存？没太明白 移除不必要的字体 注意：对缓存初始 HTML 和动态 API 的想法将信将疑，但请考虑：首先，他们的接口不会频繁改动——每天批量添加一次新的职位；其次，他们在改动发生时，在程序中清除了缓存。 git rebase 是有害的 rebase的黄金法则：永远不要在公共分支进行rebase 美团外卖前端容器化演进实践 解密国内BAT等大厂前端技术体系-携程篇 教程 逐行剖析 Vue.js 源码 工具 一个超酷的前端3d网站 本周金句 我口袋里有一个小设备，可以访问几乎全部的人类知识。我却用它与不认识的人进行毫无意义的争论，并看猫的照片。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于ueditor公式编辑器的小bug]]></title>
    <url>%2F%2Fblog%2F2019%2F12%2F%E5%85%B3%E4%BA%8Eueditor%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E5%B0%8Fbug.html</url>
    <content type="text"><![CDATA[小于号&lt;的问题http://ueditor.baidu.com/website/kityformula.html 在公式编辑器里输入&lt;，控制台里输入1ue.getContent() 获取内容：1"&lt;p&gt;&lt;img class="kfformula" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEYAAAArCAYAAADFRP4AAAABtklEQVRoQ+3Wv0tWURzH8ZfiIC0OhS1Bizrk0JJTNDk1SYEQTS0VDkamkf9C/oAyNEEI1D+gliZdndwagkBajMYGbYyQC/eCgk88x+d6702+Zz7n3PN53/f3e06XGKcS6AoupxMIMC3MCDABJq1phDFhTBiTRiCMSeMVPSaMCWPSCIQxabyix4QxF9OYbgziW1q8s89ueildwgO8whAu49fZ47a/sqlgruIpZvIoK1jGfvvROpvZNDDDeIYn+IE5rOOgs5jpq5sAJjvDKF7gLnZzIJ/wJz1SOSvqBNOLccziBj5iETvlROtslzrAXMFjPEc/lvAOe51FKXd11WDGkJVINjJT1qq6ZVKxVQ0ma67vcScvmXl8rrOXtAJWNZjiHLcwhYf4jgVs4nfqnz2v+XWBKfJcx0T+gDvEG6zi53kFbnffusEU5+zDo/xBdw0f8BZf2g1S9rymgCly9eAeXmIEW3mZbeNv2eH/tV/TwBw/621M56C+4jU2qoLTZDAFgwFM4j5uVnW9/w9gqpLkxHcCTAvsASbApFVkGBPGhDFpBMKYNF7RY8KYMCaNQBiTxit6TAteR75YLyyndV0xAAAAAElFTkSuQmCC" data-latex="&amp;lt;"/&gt;&lt;/p&gt;" 而输入 1ue.getPlainTxt() 获取内容出错12"&lt;img class="kfformula" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEYAAAArCAYAAADFRP4AAAABtklEQVRoQ+3Wv0tWURzH8ZfiIC0OhS1Bizrk0JJTNDk1SYEQTS0VDkamkf9C/oAyNEEI1D+gliZdndwagkBajMYGbYyQC/eCgk88x+d6702+Zz7n3PN53/f3e06XGKcS6AoupxMIMC3MCDABJq1phDFhTBiTRiCMSeMVPSaMCWPSCIQxabyix4QxF9OYbgziW1q8s89ueildwgO8whAu49fZ47a/sqlgruIpZvIoK1jGfvvROpvZNDDDeIYn+IE5rOOgs5jpq5sAJjvDKF7gLnZzIJ/wJz1SOSvqBNOLccziBj5iETvlROtslzrAXMFjPEc/lvAOe51FKXd11WDGkJVINjJT1qq6ZVKxVQ0ma67vcScvmXl8rrOXtAJWNZjiHLcwhYf4jgVs4nfqnz2v+XWBKfJcx0T+gDvEG6zi53kFbnffusEU5+zDo/xBdw0f8BZf2g1S9rymgCly9eAeXmIEW3mZbeNv2eH/tV/TwBw/621M56C+4jU2qoLTZDAFgwFM4j5uVnW9/w9gqpLkxHcCTAvsASbApFVkGBPGhDFpBMKYNF7RY8KYMCaNQBiTxit6TAteR75YLyyndV0xAAAAAElFTkSuQmCC" data-latex="&lt;" _src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEYAAAArCAYAAADFRP4AAAABtklEQVRoQ+3Wv0tWURzH8ZfiIC0OhS1Bizrk0JJTNDk1SYEQTS0VDkamkf9C/oAyNEEI1D+gliZdndwagkBajMYGbYyQC/eCgk88x+d6702+Zz7n3PN53/f3e06XGKcS6AoupxMIMC3MCDABJq1phDFhTBiTRiCMSeMVPSaMCWPSCIQxabyix4QxF9OYbgziW1q8s89ueildwgO8whAu49fZ47a/sqlgruIpZvIoK1jGfvvROpvZNDDDeIYn+IE5rOOgs5jpq5sAJjvDKF7gLnZzIJ/wJz1SOSvqBNOLccziBj5iETvlROtslzrAXMFjPEc/lvAOe51FKXd11WDGkJVINjJT1qq6ZVKxVQ0ma67vcScvmXl8rrOXtAJWNZjiHLcwhYf4jgVs4nfqnz2v+XWBKfJcx0T+gDvEG6zi53kFbnffusEU5+zDo/xBdw0f8BZf2g1S9rymgCly9eAeXmIEW3mZbeNv2eH/tV/TwBw/621M56C+4jU2qoLTZDAFgwFM4j5uVnW9/w9gqpLkxHcCTAvsASbApFVkGBPGhDFpBMKYNF7RY8KYMCaNQBiTxit6TAteR75YLyyndV0xAAAAAElFTkSuQmCC"&gt;" 分析结果后来又实验，在上面ueditor的官方页面里是正常的。但是在我们自己系统里是不正常的。 为什么呢？ 首先说一下kfformula在ueditor中的dom节点是这样的： 1&lt;img class="kfformula" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEYAAAArCAYAAADFRP4AAAABtklEQVRoQ+3Wv0tWURzH8ZfiIC0OhS1Bizrk0JJTNDk1SYEQTS0VDkamkf9C/oAyNEEI1D+gliZdndwagkBajMYGbYyQC/eCgk88x+d6702+Zz7n3PN53/f3e06XGKcS6AoupxMIMC3MCDABJq1phDFhTBiTRiCMSeMVPSaMCWPSCIQxabyix4QxF9OYbgziW1q8s89ueildwgO8whAu49fZ47a/sqlgruIpZvIoK1jGfvvROpvZNDDDeIYn+IE5rOOgs5jpq5sAJjvDKF7gLnZzIJ/wJz1SOSvqBNOLccziBj5iETvlROtslzrAXMFjPEc/lvAOe51FKXd11WDGkJVINjJT1qq6ZVKxVQ0ma67vcScvmXl8rrOXtAJWNZjiHLcwhYf4jgVs4nfqnz2v+XWBKfJcx0T+gDvEG6zi53kFbnffusEU5+zDo/xBdw0f8BZf2g1S9rymgCly9eAeXmIEW3mZbeNv2eH/tV/TwBw/621M56C+4jU2qoLTZDAFgwFM4j5uVnW9/w9gqpLkxHcCTAvsASbApFVkGBPGhDFpBMKYNF7RY8KYMCaNQBiTxit6TAteR75YLyyndV0xAAAAAElFTkSuQmCC" data-latex="&lt;" _src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEYAAAArCAYAAADFRP4AAAABtklEQVRoQ+3Wv0tWURzH8ZfiIC0OhS1Bizrk0JJTNDk1SYEQTS0VDkamkf9C/oAyNEEI1D+gliZdndwagkBajMYGbYyQC/eCgk88x+d6702+Zz7n3PN53/f3e06XGKcS6AoupxMIMC3MCDABJq1phDFhTBiTRiCMSeMVPSaMCWPSCIQxabyix4QxF9OYbgziW1q8s89ueildwgO8whAu49fZ47a/sqlgruIpZvIoK1jGfvvROpvZNDDDeIYn+IE5rOOgs5jpq5sAJjvDKF7gLnZzIJ/wJz1SOSvqBNOLccziBj5iETvlROtslzrAXMFjPEc/lvAOe51FKXd11WDGkJVINjJT1qq6ZVKxVQ0ma67vcScvmXl8rrOXtAJWNZjiHLcwhYf4jgVs4nfqnz2v+XWBKfJcx0T+gDvEG6zi53kFbnffusEU5+zDo/xBdw0f8BZf2g1S9rymgCly9eAeXmIEW3mZbeNv2eH/tV/TwBw/621M56C+4jU2qoLTZDAFgwFM4j5uVnW9/w9gqpLkxHcCTAvsASbApFVkGBPGhDFpBMKYNF7RY8KYMCaNQBiTxit6TAteR75YLyyndV0xAAAAAElFTkSuQmCC"&gt; 而在题库系统里是这样的 1&lt;img class="kfformula" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEYAAAArCAYAAADFRP4AAAABtklEQVRoQ+3Wv0tWURzH8ZfiIC0OhS1Bizrk0JJTNDk1SYEQTS0VDkamkf9C/oAyNEEI1D+gliZdndwagkBajMYGbYyQC/eCgk88x+d6702+Zz7n3PN53/f3e06XGKcS6AoupxMIMC3MCDABJq1phDFhTBiTRiCMSeMVPSaMCWPSCIQxabyix4QxF9OYbgziW1q8s89ueildwgO8whAu49fZ47a/sqlgruIpZvIoK1jGfvvROpvZNDDDeIYn+IE5rOOgs5jpq5sAJjvDKF7gLnZzIJ/wJz1SOSvqBNOLccziBj5iETvlROtslzrAXMFjPEc/lvAOe51FKXd11WDGkJVINjJT1qq6ZVKxVQ0ma67vcScvmXl8rrOXtAJWNZjiHLcwhYf4jgVs4nfqnz2v+XWBKfJcx0T+gDvEG6zi53kFbnffusEU5+zDo/xBdw0f8BZf2g1S9rymgCly9eAeXmIEW3mZbeNv2eH/tV/TwBw/621M56C+4jU2qoLTZDAFgwFM4j5uVnW9/w9gqpLkxHcCTAvsASbApFVkGBPGhDFpBMKYNF7RY8KYMCaNQBiTxit6TAteR75YLyyndV0xAAAAAElFTkSuQmCC" data-latex="&lt;" &gt; 区别在于处于自身业务需要，把_src字段去掉了。这样有什么问题呢？ 看一下ueditor的getPlainTxt方法是如何实现的 123456789101112getPlainTxt: function () &#123; var reg = new RegExp(domUtils.fillChar, 'g'), html = this.body.innerHTML.replace(/[\n\r]/g, '');//ie要先去了\n在处理 html = html.replace(/&lt;(p|div)[^&gt;]*&gt;(&lt;br\/?&gt;|&amp;nbsp;)&lt;\/\1&gt;/gi, '\n') .replace(/&lt;br\/?&gt;/gi, '\n') .replace(/&lt;[^&gt;/]+&gt;/g, '') .replace(/(\n)?&lt;\/([^&gt;]+)&gt;/g, function (a, b, c) &#123; return dtd.$block[c] ? '' : b ? b : ''; &#125;); //取出来的空格会有c2a0会变成乱码，处理这种情况\u00a0 return html.replace(reg, '').replace(/\u00a0/g, ' ').replace(/&amp;nbsp;/g, ' ');&#125;, 重点是这个.replace(/&lt;[^&gt;/]+&gt;/g, &#39;&#39;)，它是把所有&lt;开头&gt;结束（里面不能包含&gt;或/）里面的内容（包含括号）全部置空。 而如果公式图片的data-latex字段里包含&lt;，会被识别，并与img的结束&gt;（不知道为啥这个img不是以/&gt;结束)配成一对符合上述正则表达式的内容清除掉，就会得到上面getPlainTxt的错误结果。 - 为什么没有清理img标签呢？ 因为img的src里总会含有/符号。所以这个getPlainTxt有bug 如何解决呢？ 方案1： 把_src加回去，这样匹配的时候有/就正常了。但是把_src加回去，base64的字符串很长啊，算了。当然，也可以加一个别的字段，类似_src=”/“只带个/，就ok了 方案2： 类似方案1的思路，把src放在data-latex的后面不就得了。修改ueditor/kityformulaDialog.html中的 1234567 editor.execCommand('inserthtml', '&lt;img class="kfformula" src="'+ data.img +'" data-latex="' + latex + '" style="zoom: 65%; max-width: 100%" /&gt;');``` 改为：```js editor.execCommand('inserthtml', '&lt;img class="kfformula" data-latex="' + latex + '" src="' + data.img +'" style="zoom: 65%; max-width: 100%" /&gt;'); 方案3： 改造getPlainTxt中的正则表达式，把.replace(/&lt;[^&gt;/]+&gt;/g, &#39;&#39;)改为.replace(/&lt;(?!\/&gt;)(?!&quot;&gt;).+&gt;/g, &#39;&#39;)即可]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ueditor</tag>
        <tag>采坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-11前端月报]]></title>
    <url>%2F%2Fblog%2F2019%2F11%2F2019-11%E5%89%8D%E7%AB%AF%E6%9C%88%E6%8A%A5.html</url>
    <content type="text"><![CDATA[新闻 VScode发布在线版本 chrome 78 GitLab 开启地域封锁之时，GitHub 在中国畅谈无国界 谷歌推出新提案 Portals：Web 上的无缝跳转体验 “狗屁不通文章生成器”登顶GitHub热榜？ 2019 TWeb 腾讯前端技术大会精彩回顾 React Conf 2019 技术 解密HTTP/2与HTTP/3 的新特性 HTTP/1.1缺陷（由于队头阻塞造成的网络延迟； HTTP头部过大；明文传输不安全） HTTP/2特性 （二进制格式传输数据；压缩header；多路复用） HTTP/3 （UDP；QUIC协议实现可靠传输） 这可能是最通俗的 React Fiber(时间分片) 打开方式 一文彻底搞懂react hooks的原理和实现 腾讯视频Node.js服务是如何支撑国庆阅兵直播高并发的？ 文章 长连接/websocket/SSE等主流服务器推送技术比较 WebAssembly 现状与实战 前端代码质量-圈复杂度原理和实践 「前端进阶」高性能渲染十万条数据(虚拟列表) 前端安全系列（一）：如何防止XSS攻击？ 我的前端成长之路 一个程序员的成长之路 工具 精读《What’s new in javascript》 Build your own React]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[antd-modal源码解析]]></title>
    <url>%2F%2Fblog%2F2019%2F11%2Fantd-modal%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"><![CDATA[antd modal弹窗模块，是基于rc-dialog进行二次开发的。代码部分在src/components/modal中就是modal部分的源码。 将antd modal源码扒下来，ts改为js，代码在这里：https://github.com/handv/antd-modal rc-dialog参数 name type default description getContainer HTMLElement | () =&gt; HTMLElement | Selectors | false document.body 指定 Modal 挂载的 HTML 节点, false 为挂载在当前 dom prefixCls string rc-dialog dialog节点的类名前缀 wrapClassName string 无 对话框外层容器的类名 footer string|ReactNode 确定取消按钮 底部内容，当不需要默认底部按钮时，可以设为 footer={null} visible boolean false 对话框是否可见 mousePosition {x:number,y:number} 无 设置当前鼠标的坐标pageX和pageY onClose function 无 点击关闭图标或蒙层时调用 closeIcon ReactNode 无 自定义关闭图标 原理 footer modal有一个默认footer，带确定和取消的两个ActionButton ActionButton 二次封装后的antd-Button，带一个onClick方法 123456789101112131415161718192021222324252627282930313233onClick = () =&gt; &#123; const &#123; actionFn, closeModal &#125; = this.props; if (actionFn) &#123; let ret; if (actionFn.length) &#123; ret = actionFn(closeModal); &#125; else &#123; ret = actionFn(); if (!ret) &#123; closeModal(); &#125; &#125; if (ret &amp;&amp; ret.then) &#123; this.setState(&#123; loading: true &#125;); ret.then( (...args) =&gt; &#123; // It's unnecessary to set loading=false, for the Modal will be unmounted after close. // this.setState(&#123; loading: false &#125;); closeModal(...args); &#125;, (e) =&gt; &#123; // Emit error when catch promise reject // eslint-disable-next-line no-console console.error(e); // See: https://github.com/ant-design/ant-design/issues/6183 this.setState(&#123; loading: false &#125;); &#125;, ); &#125; &#125; else &#123; closeModal(); &#125;&#125;; Modal.info / Modal.error / Modal.warn / Modal.success 代码见src/components/modal/index.js, footer={null} 此部分实现了一个confirm(…props)方法。 confirm里有个visible的参数，还有一个render的方法。在执行confirm()的时候，会调用render()生成一个 confirm里还有一个close方法，在点击右上角关闭的时候，会调用close(),生成一个]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>antd</tag>
        <tag>javascript</tag>
        <tag>源码</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-10前端月报]]></title>
    <url>%2F%2Fblog%2F2019%2F10%2F2019-10%E5%89%8D%E7%AB%AF%E6%9C%88%E6%8A%A5.html</url>
    <content type="text"><![CDATA[新闻 Google 宣称率先实现量子霸权 谷歌新增链接属性 rel=”sponsored”来自广告赞助商链接 rel=”ugc” 用户提供的链接 rel=”nofollow” 完全忽略该链接 目的是帮助搜索引擎更好的判断链接的性质 Chrome 将不再允许 https:// 页面加载 HTTP 资源 Chrome 安全小组近日在一篇博客文章中表示，计划使 https://页面不再加载 HTTP子资源 提供开启/关闭按钮，控制mixed content 自动升级http为https Top-level await 允许在代码顶层直接使用await 可用于包动态引入等 影响包的执行顺序：会影响当前和调用模块的执行 存在部分疑问：详见内容 技术 解密HTTP/2与HTTP/3 的新特性 HTTP/1.1缺陷（由于队头阻塞造成的网络延迟； HTTP头部过大；明文传输不安全） HTTP/2特性 （二进制格式传输数据；压缩header；多路复用） HTTP/3 （UDP；QUIC协议实现可靠传输） 这可能是最通俗的 React Fiber(时间分片) 打开方式 文章 Why you should use package-lock.json What is the difference between “npm install” and “npm ci”? npm install以package.json为主 npm ci以package-lock.json为主 Git 是如何做版本控制 git存放数据在objects文件夹中 每次提交时，文件变更，会保存一个快照（2+38命名） 通过树对象，将文件不同版本和提交记录关联 .git/refs/heads保存本地分支 小程序工程化探索 工具 thefuck,linux命令纠正助手 表情包库 起名神器]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css实现一个圆角三角形]]></title>
    <url>%2F%2Fblog%2F2019%2F10%2Fcss%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%9C%86%E8%A7%92%E4%B8%89%E8%A7%92%E5%BD%A2.html</url>
    <content type="text"><![CDATA[项目中有个实现三角图标的需求，因为ui同学没空，所以自己就用css实现了一下，同时推荐一下这个网站，实现样式如下： 1234567#triangle-right &#123; width: 0; height: 0; border-top: 50px solid transparent; border-left: 100px solid red; border-bottom: 50px solid transparent;&#125; 但debug的时候，ui同学说我稿里的三角形是圆角的，怎么办呢？要么找ui要图，要么自己实现，自己实现的放大后不会虚化对吧。那就自己来吧，这个实现起来难度大了点： 123&lt;body&gt; &lt;div class="triangle"&gt;&lt;/div&gt;&lt;/body&gt; 1234567891011121314151617181920212223242526.triangle, .triangle:before, .triangle:after &#123; width: 4em; height: 4em; &#125;.triangle &#123; overflow: hidden; position: relative; margin: 7em auto 0; border-radius: 20%; transform: translateY(50%) rotate(120deg) skewY(30deg) scaleX(.866); cursor: pointer; pointer-events: none;&#125; .triangle:before, .triangle:after &#123; position: absolute; background: orange; pointer-events: auto; content: '';&#125;.triangle:before &#123; border-radius: 20% 20% 20% 53%; transform: scaleX(1.155) skewY(-30deg) rotate(-30deg) translateY(-42.3%) skewX(30deg) scaleY(.866) translateX(-24%);&#125;.triangle:after &#123; border-radius: 20% 20% 53% 20%; transform: scaleX(1.155) skewY(-30deg) rotate(-30deg) translateY(-42.3%) skewX(-30deg) scaleY(.866) translateX(24%);&#125; mark一下]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>备忘</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-09前端月报]]></title>
    <url>%2F%2Fblog%2F2019%2F09%2F2019-09%E5%89%8D%E7%AB%AF%E6%9C%88%E6%8A%A5.html</url>
    <content type="text"><![CDATA[新闻 W3C 首次发布小程序标准化白皮书 这份文档并非正式的 W3C 推荐标准，只是一份关于小程序的介绍性技术报告，属于 W3C 的兴趣组笔记，旨在为小程序后续与 Web 以及浏览器的后续交流合作、相互补充、融合发展做铺垫。 这份文档由 W3C 中文兴趣组成员合作编写。 原文文档，文章作者没有微信的人，文中提及主流的小程序没有微信（😔，格局） Flutter 1.9正式发布 Flutter’s Web Support集成到了 Flutter 主库中，让开发人员可以使用同一套代码库为移动、桌面和 Web 平台开发应用 支持macOS Catalina和iOS 13操作系统 新的 Material 小部件 增加了对南非荷兰语、祖鲁语等 24 种新语言的支持 Dart 2.5 发布，为 IDE 引入了机器学习驱动的代码自动完成功能 iOS 新项目默认使用 Swift 取代了 Objective-C，而 Android 新项目默认使用 Kotlin 取代了 Java 新版 React DevTools 2019.09.19 发布4.1.0 需要的react版本 react 15.x以上支持 react-native 0.62以上支持(0.62尚未发布) 新特性 添加组件过滤器 props可编辑 添加render by list,顺藤摸瓜找到父组件 Owners tree，我自己的组件树 hooks支持 去掉水平滚动条 HOCs 一目了然 Suspense API DevTools profiler性能分析，且可以分享分析报告 技术 66个值得收藏的CSS开发技巧 文章 忍者代码 学会忍者代码，看别人会不会打死你 工具 正则学习教程 表情包库 起名神器]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-08前端月报]]></title>
    <url>%2F%2Fblog%2F2019%2F08%2F2019-08%E5%89%8D%E7%AB%AF%E6%9C%88%E6%8A%A5.html</url>
    <content type="text"><![CDATA[新闻 Electron 6.0.0 ts3.6，更加严谨的generator，Iterator，类型 技术 深入理解Node.js 中的进程与线程 webpack原理与实战 css奇技淫巧 css实现rate react hook下的性能优化 文章 超全的设计模式简介（45种） 小程序运行机制 阿里微前端框架 工具 手绘效果的图表库]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-07前端月报]]></title>
    <url>%2F%2Fblog%2F2019%2F07%2F2019-07%E5%89%8D%E7%AB%AF%E6%9C%88%E6%8A%A5.html</url>
    <content type="text"><![CDATA[新闻 Facebook发布全新JS引擎！专注提高React Native应用的性能 谷歌下一代操作系统FuchsiaOS开发者网站上线 技术 前端团队代码评审 CheckList 清单 浮点数转换成整型时，应该使用Math.floor()或者Math.round()，而不是使用parseInt() 使用多态替换条件语句 Vue中script 标签内部声明顺序:data &gt; prop &gt; components &gt; filter &gt; computed &gt; watch &gt; 钩子函数（钩子函数按其执行顺序）&gt; methods 彻底理解服务端渲染原理(8千字汇总长文) 从一个基础的react组件SSR开始实现 同构项目中引入Redux（客户端、服务端与store的连接–都通过react-redux中的Provider来传递store） 异步数据的服务端渲染方案 Preload, Prefetch And Priorities in Chrome JS变量生命周期:为什么 let 没有被提升 先使用，再声明，这样会造成混淆 提升的原理：变量生命周期（声明阶段；初始化阶段；赋值阶段） 提升在let生命周期中无效的原因：提升是变量在作用域顶部的耦合声明和初始化阶段。然而，let生命周期分离声明和初始化阶段。解耦消除了let的提升期限 面试 一个合格的中级前端工程师需要掌握的 28 个 JavaScript 技巧 Javascript 面试核心考点 8年前端开发的知识点沉淀 JavaScript设计原则&amp;&amp;常用设计模式 JavaScript 算法与数据结构 工具 一个具有手绘效果的css网站]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间格式化]]></title>
    <url>%2F%2Fblog%2F2019%2F07%2F%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96.html</url>
    <content type="text"><![CDATA[类似moment的时间戳转换格式12345678910111213141516171819202122232425262728293031323334353637383940/** * 将「时间戳」转换为「日期时间」 * @param timeStamp 时间戳 * @param fmt 时间格式，如：「YYYY:MM:DD hh:mm」 */const getDate = (timeStamp = 0, fmt) =&gt; &#123; let date = new Date(timeStamp), year = date.getFullYear(), month = leftPad(date.getMonth() + 1), day = leftPad(date.getDate()), hour = leftPad(date.getHours()), minus = leftPad(date.getMinutes()), secondes = leftPad(date.getSeconds()); if(fmt)&#123; if (/(Y+)/.test(fmt)) &#123; fmt = fmt.replace(RegExp.$1,(year + '').substr(4 - RegExp.$1.length)) &#125; let o = &#123; 'M+': month, 'D+': day, 'h+': hour, 'm+': minus, 's+': secondes &#125; for (let k in o) &#123; if (new RegExp(`($&#123;k&#125;)`).test(fmt)) &#123; let str = o[k] + '' fmt = fmt.replace(RegExp.$1, str) &#125; &#125; return fmt &#125;&#125;// 左填充const leftPad = (string) =&gt; &#123; if (String(string).length &lt; 2) return `0$&#123;string&#125;` return string&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>备忘</tag>
        <tag>moment</tag>
        <tag>time format</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-06前端月报]]></title>
    <url>%2F%2Fblog%2F2019%2F06%2F2019-06%E5%89%8D%E7%AB%AF%E6%9C%88%E6%8A%A5.html</url>
    <content type="text"><![CDATA[新闻 Chrome 浏览器计划加强 cookie 限制 使用SameSite属性，使用户能够清除所有此类cookie，同时保持单域cookie不受影响，从而保留用户登录和设置 将跨站点cookie限制为HTTPS连接 对指纹识别的保护 建议在各家浏览器稳定支持还是不要用了 TypeScript 3.5发布，构建时间减少 68%、新增 Omit 类型、UMD 全局访问等等 中文翻译 V8 release v7.6 性能方面： JSON.parse方法：1. 自己管理一个堆栈，不依赖原始堆栈 2. 先解析，然后分配空间（之前是预分配足够大的空间） Frozen/sealed array Unicode string handling JS语言特性 Promise.allSettled Improved BigInt support Native stack 技术 危险的 target=”_blank” 与 “opener” 中文翻译 window.opener - 如果当前窗口是由另一个窗口打开的, window.opener保留了那个窗口的引用 影响： 如果，你的网站上有一个链接，使用了 target=”_blank”，那么一旦用户点击这个链接并进入一个新的标签，新标签中的页面如果存在恶意代码，就可以将你的网站直接导航到一个虚假网站。此时，如果用户回到你的标签页，看到的就是被替换过的页面了。 在新打开的页面，执行window.opener.location.replace(‘https://baidu.com/&#39;)，会将之前的网站的地址变成百度。 网站使用了 &lt;a target=&quot;_blank&quot;&gt;，那么新打开的标签页的性能将会影响到当前页面。 防御： rel=”noreferrer” 保证来源隐私安全 rel=”noopener” 保证无法使用opener对象 兼容性 123456"use strict";function openUrl(url) &#123; var newTab = window.open(); newTab.opener = null; newTab.location = url;&#125; Chrome官方——资源优先级 预加载, 如字体文件，关键路径 CSS 和 JavaScript 预连接 预提取(主站课程详情页到下单页可以考虑使用) Preload, Prefetch And Priorities in Chrome 如何编写深色主题的CSS 一种聪明而优雅的方法 filter: invert: 改版元素颜色 filter: hue-rotate: 改版元素色调123.message--dark &#123; filter: invert(100) hue-rotate(180deg);&#125; 只使用 CSS 的实时聊天 作者灵感来源： https://twitter.com/davywtf/status/1124130932573839360 原理：大概是每一个按钮都是一个css样式，点击按钮发送图片请求，服务端接收到请求，发送到客户端图片 123.some-button:active &#123; background-image: url('some_image.jpg')&#125; 看README： 12345Practical DetailsIf you want to install and use this locally you should:1. Re-evaluate your life choices2. If you simply must continue, check out INSTALL.md 文章 阿里前端委员会主席圆心：前端路上的思考 破坏程序员生产力的 12 件事 中文翻译 像程序员一样思考: 如何解决问题 中文翻译 最好的方法: 掌握一套框架 不断实践框架 react for 面试 工具 gridea 一款跨平台桌面软件，可以在本地将 Markdown 文档编译成静态博客，然后发布到 GitHub Pages 或 Coding Pages [Giflens] vscode插件，可以预览gif图片 小红书用的弹幕播放器dplayer Bit Bit 是一个支持组件即服务的在线平台，可以在线托管存在组件，支持组件查找，组件版本号，独立运行，并且支持不同项目的组件集成。Bit 解决了管理组件系统这个通用问题，并且将开发人员从持续造轮子解脱，提高开发效率。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解现代浏览器]]></title>
    <url>%2F%2Fblog%2F2019%2F06%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%8E%B0%E4%BB%A3%E6%B5%8F%E8%A7%88%E5%99%A8.html</url>
    <content type="text"><![CDATA[看了深入理解现代浏览器这篇文章，写的非常好，记录一下。 开始划重点： 架构篇 chrome最新架构: 浏览器进程：控制浏览器这个应用的chrome（主框架）部分，包括地址栏、书签、前进/后退按钮等，同时也会处理浏览器不可见的高权限任务，如发送网络请求、访问文件。 渲染器进程：负责在标签页中显示网站及处理事件。 插件进程：控制网站用到的所有插件。 GPU进程：在独立的进程中处理GPU任务。之所以放到独立的进程，是因为GPU要处理来自多个应用的请求，但要在同一个界面上绘制图形。 进程处理 正常情况，一个标签页就是一个渲染器进程。 为节省内存，Chrome会限制自己可以打开的进程数量。限制的条件取决于设备内存和CPU配置。达到限制条件后，Chrome会用一个进程处理同一个站点的多个标签页。 站点隔离（http://t.cn/RgNAwLC）。站点隔离是新近引入Chrome的一个里程碑式特性，即每个跨站点iframe都运行一个独立的`渲染器进程`。 导航篇 标签页外面的一切都由浏览器进程处理，包括以下线程： UI线程负责绘制浏览器的按钮和地址栏 网络线程负责处理网络请求并从互联网接收数据 存储线程负责访问文件和存储数据 输入url后 第一步：处理输入。UI线程会判断用户输入的是查询字符串还是URL 第二步：开始导航。如果输入的是URL，UI线程会通知网络线程发起网络调用，获取网站内容 第三步：读取响应。服务器返回的响应体到来之后，网络线程会检查接收到的前几个字节。 1如果响应是HTML文件，那下一步就是把数据交给`渲染器进程`。但如果是一个zip文件或其他文件，那就意味着是一个下载请求，需要把数据传给`下载管理器`。 第四步：联系渲染器进程。网络线程确认浏览器可以导航到用户请求的网站，通知UI线程数据已经准备好了。UI线程会联系渲染器进程渲染网页。 第五步：提交导航。数据和渲染器进程都有了，就可以通过IPC(进程间通信)从浏览器进程向渲染器进程提交导航。渲染器进程也会同时接收到不间断的HTML数据流。当浏览器进程收到渲染器进程的确认消息后，导航完成，文档加载阶段开始。 最后一步：初始加载完成。提交导航之后，渲染器进程将负责加载资源和渲染页面（具体细节后面介绍）。而在“完成”渲染后（在所有iframe中的onload事件触发且执行完成后），渲染器进程会通过IPC给浏览器进程发送一个消息。此时，UI线程停止标签页上的旋转图标。 如果此时用户在地址又输入了其他URL呢？ 1)浏览器进程还会重复上述步骤，导航到新站点。2)在此之前，需要确认已渲染的网站是否关注beforeunload事件。3)如果有beforeunload事件，必须渲染器进程执行完毕，浏览器进程才能导航到新站点。4)导航到不同的网站时，会有一个新的独立渲染器进程负责处理新导航，而老的渲染器进程要负责处理unload之类的事件。 渲染篇 标签页中的一切都由渲染器进程负责处理 主线程负责运行大多数客户端JavaScript代码 少量代码可能会由工作线程处理（如果用到了Web Worker或Service Worker） 合成器（compositor）线程和栅格化（raster）线程负责高效、平滑地渲染页面 加载子资源 Chrome会在解析同时并发运行“预加载扫描器”，当发现HTML文档中有&lt;img&gt;或&lt;link&gt;时，预加载扫描器会将请求提交给浏览器进程中的网络线程。 交互篇 用户交互比如触摸事件发生时的过程： 浏览器进程首先接收到该手势。但是，浏览器进程仅仅知道手势发生在哪里， 浏览器进程会把事件类型（如touchstart）及其坐标发送给渲染器进程处理这个事件，即根据事件目标来运行注册的监听程序。因为标签页中的内容是渲染器进程处理。 事件处理 输入事件是由渲染器进程中的合成器线程处理的。 如果页面上没有注册事件监听程序，那合成器线程可以完全独立于主线程生成新的合成器帧。 如果页面上注册了事件监听程序呢？此时合成器线程怎么知道是否有事件要处理？ 为什么事件监听要加上passive:true? 123document.body.addEventListener('touchstart', evt =&gt; &#123; ...&#125;, &#123; passive: true &#125;) 自己看文章吧 大概原理是，如果把事件监听都挂载到document.body, 那么在处理每一次事件的时候，都需要渲染器进程的合成器线程先进行js事件的判断，再合成新帧。而加了这个之后，就可以同步进行了。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-05前端月报]]></title>
    <url>%2F%2Fblog%2F2019%2F05%2F2019-05%E5%89%8D%E7%AB%AF%E6%9C%88%E6%8A%A5.html</url>
    <content type="text"><![CDATA[新闻 Google开发者大会(全部视频) 加载速度优化 浏览器性能和速度提升 浏览器实现了图像和 iframe 的懒加载，只需要给html元素增加属性 loading=”lazy” Paint Holding 的实验功能，避免闪现纯白的“加载页面“, 【弹幕：看起来就像是点击了没反应】 [Web Packaging]（https://github.com/WICG/webpackage） 增加了页面可以加载源，类似“P2P” 更强大的新特性 文件系统访问 https://github.com/WICG/native-file-system 无限配额 https://bugs.chromium.org/p/chromium/issues/detail?id=897276 基于短信的身份验证 https://github.com/sso-google/sms-otp-retrieval/blob/master/README.md Web Share Target API 形状检测 API，可以实现与本次大会上发布的 Web Perception 工具包（https://perceptiontoolkit.dev/） TWA 视频演示：https://youtu.be/XMaDMYjHP0Y， 什么是TWA 桌面版 PWA 小程序支持ChromeOS 平台 Windows、Mac 和 Linux 平台 comlink来使用 worker 的扫雷游戏 Proxx 隐私安全 新策略可以让用户决定是否允许网站追踪自己，并且可以增强 Web 整体的安全和隐私保护能力，提升透明度 Chrome 处理 Cookie 策略的重要变化： https://blog.chromium.org/2019/05/improving-privacy-and-security-on-web.html 改善开发者体验 web.dev学习教程eg. react 和工具使用文档 eg. lighthouse QCon大会(PPT可下载) 前端场里，百度amis还不错 2019 new Javasscript JS 解析快了 2 倍 async 执行快了 11 倍 平均减少了 20% 的内存使用 class fileds 可以直接在 class 中初始化变量不用写在 constructor 里 私有变量前缀 string.matchAll 用来做正则多次匹配 numeric seperator 允许我们在写数字的时候使用 _ 作为分隔符提高可读性 bigint 新的大数字类型支持 Intl.NumberFormat 本地化格式化数字显示 Array.prototype.flat(), Array.prototype.flatMap() 多层数组打平方法 Object.entries() 和 Object.fromEntries() 快速对对象进行数组操作 globalThis 无环境依赖的全局 this 支持 Array.prototype.sort() 的排序结果稳定输出 Intl.RelativeTimeFormat(), Intl.DateTimeFormat() 本地化显示时间 Intl.ListFormat() 本地化显示多个名词列表 Intl.locale() 提供某一本地化语言的各种常量查询 顶级 await 无需写 async 的支持 Promise.allSettled() 和 Promise.any() 的增加丰富 Promise 场景 WeakRef 类型用来做部分变量弱引用减少内存泄露 React Native还没完！ Facebook App 的改版使用了 React Native,进一步扩大了 React Native 的应用范围:视频 在 Facebook 里面 RN 的使用很广泛，产品包括：Ads Manager, Oculus Companion, Marketplace, Dating, Jobs, Profile, Settings, Blood Donations, Crisis Response 等等 去年 RN 的大规模重构，使用 C++ 重写了 RN 的核心部分:https://www.youtube.com/watch?v=UcqRXTriUVI RN 得到了微软的大力支持，你可以用 RN 直接编写 Windows 平台的 UWP 应用 Flutter1.5来了！全平台制霸！ Flutter 1.5：新的 App Store iOS SDK 更新、iOS 与 Material 小工具更新、引擎对于新型设备的支持，Dart 2.3 带来的全新 UI-as-code 语言功能等等 投资建立技术支持生态系统，目前 Flutter 项目拥有超过 2000 个可用的开源软件包 从移动到多平台：Flutter for Web 正尝试在各类嵌入式设备之上运行 Flutter 应用程序 svelte:又一个前端框架，类似 vue 乍看结构很像vue,一个.svelte文件里包括了 script、style、html 提供了一套全新的语法 Svelte不依赖于虚拟DOM，在构建时运行 Vuex3.1.1 更新：支持 jsDelivr，修复内存泄漏 支持在 NativeScript 应用中调试 Vuex 从uglify换成Terser&amp;支持了type=module的直接加载方式 支持jsdelivr 修复内存泄漏 技术 HTTPS的页面发送不了HTTP请求 MPEG-DASH在bilibili的应用与实践 自适应比特率串流技术， 2011 年 11 月成为国际标准 自适应码率、无缝切换、降低卡顿率 B站在2018年9月将其全量，卡顿率对比 HTTP-FLV 有大幅降低 微信，支付宝小程序实现原理概述 对比了小程序和普通网页的区别 运行环境不同，普通网页开发可以使用各种浏览器提供的 DOM API，进行 DOM 操作 小程序渲染层和逻辑层运行在不同线程中，且渲染层存在多个WebView线程 执行环境不同 分析了小程序为何选择hybrid技术 避免单线程阻塞，用户体验好 方便发布新版本 详细介绍了小程序的双线程模型 线程之间相互独立，通过微信客户端进行通信 渲染层模拟渲染层DOM树，当调用setData后通过Native层传递数据，渲染层对比新旧DOM树后更新。 介绍了小程序的运行&amp;更新&amp;事件处理机制 说明为什么我们要避免频繁的setData setData会占用渲染层的js线程，从而阻塞事件传递到逻辑层。 setData会传递大量新数据 工具 即拿即用的 CSS 小功能，直接 copy 代码就能用起来 利用favicon展示页面加载进度 shepherd 做新手指引的工具库，目前对于Vue，React，Angular，Ember框架都有支持 Tickeys 没有机械键盘，那你就来着了 每月金句你要避免两个陷阱。一个是尝试自动化一个不完全理解的服务，另一个是盲目地相信别人的自动化，而不理解它在幕后做的事情。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现数字自增]]></title>
    <url>%2F%2Fblog%2F2019%2F05%2F%E5%AE%9E%E7%8E%B0%E6%95%B0%E5%AD%97%E8%87%AA%E5%A2%9E.html</url>
    <content type="text"><![CDATA[项目中遇到需要实现数字自增的动画效果，怎么实现呢，少废话，show me the code js实现数字从0到num的自增动画1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;数字自动增加&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 id="time"&gt;0&lt;/h1&gt; &lt;script&gt; //数字自增到某一值动画参数（目标元素,自定义配置） function NumAutoPlusAnimation(targetEle, options) &#123; /*可以自己改造下传入的参数，按照自己的需求和喜好封装该函数*/ //不传配置就把它绑定在相应html元素的data-xxxx属性上吧 options = options || &#123;&#125;; var $this = document.getElementById(targetEle), time = options.time || $this.data('time'), //总时间--毫秒为单位 finalNum = options.num || $this.data('value'), //要显示的真实数值 regulator = options.regulator || 100, //调速器，改变regulator的数值可以调节数字改变的速度 step = finalNum / (time / regulator),/*每30ms增加的数值--*/ count = 0, //计数器 initial = 0; var timer = setInterval(function() &#123; count = count + step; if(count &gt;= finalNum) &#123; clearInterval(timer); count = finalNum; &#125; //t未发生改变的话就直接返回 //避免调用text函数，提高DOM性能 var t = Math.floor(count); if(t == initial) return; initial = t; $this.innerHTML = initial; &#125;, 30); &#125; NumAutoPlusAnimation("time", &#123; time: 1500, num: 12000, regulator: 50 &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; css实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;css实现数字自动增加&lt;/title&gt; &lt;style&gt; /* 撑开高度 */.flip-number::before &#123; content: 'a'; display: block; color: transparent;&#125; /* 数字 */.flip-number::after &#123; position: absolute; width: 100%; height: 100%; top: 0; left: 0; content: '0\A 1\A 2\A 3\A 4\A 5\A 6\A 7\A 8\A 9\A 10\A' attr(data-num); display: block; white-space: pre-line; text-align: center; animation: flipNumber cubic-bezier(.12,.78,.52,1.2) 1 .4s; animation-fill-mode: forwards; will-change: transform;&#125;/* to中translateY的内容要跟数字个数对应上 */@keyframes flipNumber &#123; from &#123;transform: translateY(0%);&#125; to &#123;transform: translateY(-1100%);&#125;&#125; .flip-number &#123; position: relative; overflow: hidden; display: inline-block;&#125; /* custom styles */.flip-number &#123; font-size: 60px; background: #f88; text-align: center; width: 140px;&#125; &lt;/style&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- data-num个数就是最终想达到的个数 --&gt; &lt;span class="flip-number" data-num="10"&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>备忘</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-04前端月报]]></title>
    <url>%2F%2Fblog%2F2019%2F04%2F2019-04%E5%89%8D%E7%AB%AF%E6%9C%88%E6%8A%A5.html</url>
    <content type="text"><![CDATA[新闻 Chrome75将支持原生图片懒加载属性 在img和iframe标签上添加一个loading属性，用于原生支持懒加载 loading有三个值：lazy(懒加载)、eager(立即加载)、auto(默认) 提供了polyfill方案兼容不支持的浏览器 建议在各家浏览器稳定支持还是不要用了 基于Chromium的预览版Edge 终于来了 技术 理解webpack原理，手写一个100行的webpack 照着youtube官方的视频搞得，感觉作为新人理解webpack应该很不错 深入 setState 机制 你不知道的浏览器页面渲染机制 构建DOM的过程中： 将字节数据=&gt;字符串=&gt;Token=&gt;Node=&gt;DOM。 Token会标识出当前token是startTag，还是endTag。 构建DOM的过程中，不是等所有Token都转换完成后再去生成节点对象，而是一边生成Token一边消耗Token来生成节点对象。也就是每个Token被生成后，会立刻消耗这个Token创建出节点对象。 构建渲染树： 在渲染过程中遇到js时，不只是阻塞DOM的构建，它会导致CSSOM也阻塞DOM的构建。 因为js不只可以改DOM，它还可以更改样式，也就是它可以更改CSSOM。不完整的CSSOM是无法使用的，如果js想访问CSSOM并更改它，那么在执行js时，必须要能拿到完整的CSSOM。 因此浏览器会先下载和构建CSSOM，然后再执行JavaScript，最后在继续构建DOM 文章 浅谈：前端如何赋能业务 前端专业方向的尽头 学习路线启示 大神也有不擅长的地方 学习自己感兴趣的领域 工具 基于react的加载动画库 利用favicon展示页面加载进度 js执行可视化，学习上下文、闭包 每月金句每家公司都说：”我们非常重视您的隐私和安全。”请不要再说这种话了，大多数公司并不关心数据的隐私或安全，而是为了数据被盗时，他们有一个向客户解释的说辞。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试系列：从一道单例题讲起]]></title>
    <url>%2F%2Fblog%2F2019%2F04%2F%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%EF%BC%9A%E4%BB%8E%E4%B8%80%E9%81%93%E5%8D%95%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%B5%B7.html</url>
    <content type="text"><![CDATA[引子弱鸡刷scriptoj的时候，看到这么一道单例试题： 12345678910111213141516171819202122232425262728293031单例模式（Singleton）是一种常用的软件设计模式，它保证我们系统中的某一个类在任何情况实例化的时候都获得同一个实例。例如：const root1 = new Root()const root2 = new Root()const root3 = new Root()root1 === root2 // trueroot2 === root3 // true我们构造一个名为 singletonify 方法，可以传入一个用户自定义的类，可以返回一个新的单例模式的类。例如：class A () &#123;&#125;const SingleA = singletonify(A)const a1 = new SingleA()const a2 = new SingleA()const a3 = new SingleA()a1 === a2 // =&gt; truea2 === a3 // =&gt; true注意，你要保证 singletonify 返回的类的实例也是原来的类的实例：a1 instanceof A // =&gt; truea1 instanceof SingleA // =&gt; true自定义的类属性也要保持一致，例如：class A () &#123;&#125;A.staticMethod = () =&gt; &#123;&#125;const SingleA = singletonify(A)SingleA.staticMethod === A.staticMethod // =&gt; true请你完成 singletonify 的编写。 我就稀里糊涂的写了这么个答案，居然通过了!!! 12345678910111213141516171819const singletonify = (OriginalClass) =&gt; &#123; let singleton = null function init() &#123; const sl = new OriginalClass() sl.__proto__ = OriginalClass.prototype return sl &#125; const myConstrutor = function () &#123; if (!singleton) &#123; singleton = init() &#125; return singleton &#125; myConstrutor.prototype = OriginalClass.prototype Object.getOwnPropertyNames(OriginalClass).forEach((val, idx, array) =&gt; &#123; myConstrutor[val] = OriginalClass[val] &#125;) return myConstrutor&#125; 但翻看答案的时候，发现考察的点确是Proxy，这块的知识点没点上，那就看看MDN上是咋写的。 ProxyProxy，顾名思义是个代理，代理干啥呢，代理给target添加新的功能handler，又不用修改target本身。按照阮一峰老师在ES6中的解释，proxy就相当于java web中的拦截器，在正式使用target之前赋予其一些handler的功能。 语法1let p = new Proxy(target, handler); 参数 target用Proxy包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。 handler一个对象，其属性是当执行一个操作时定义代理的行为的函数。 看一下MDN上这个示例吧，扩展构造函数123456789101112131415161718192021222324252627282930313233343536function extend(sup,base) &#123; var descriptor = Object.getOwnPropertyDescriptor( base.prototype,"constructor" ); base.prototype = Object.create(sup.prototype); var handler = &#123; construct: function(target, args) &#123; var obj = Object.create(base.prototype); this.apply(target,obj,args); return obj; &#125;, apply: function(target, that, args) &#123; sup.apply(that,args); base.apply(that,args); &#125; &#125;; var proxy = new Proxy(base,handler); descriptor.value = proxy; Object.defineProperty(base.prototype, "constructor", descriptor); return proxy;&#125;var Person = function(name)&#123; this.name = name&#125;;var Boy = extend(Person, function(name, age) &#123; this.age = age;&#125;);Boy.prototype.sex = "M";var Peter = new Boy("Peter", 13);console.log(Peter.sex); // "M"console.log(Peter.name); // "Peter"console.log(Peter.age); // 13 好多不太熟悉的函数😓，我们来了解一下吧 Object​.getOwnPropertyDescriptor返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）属性描述符是一个类似这样的对象： 12345678&#123; configurable: true, enumerable: true, get: /*the getter function*/, set: undefined, value: 42, writable: true&#125; Object​.create()创建一个新对象，使用现有的对象来提供新创建的对象的proto Object​.defineProperty会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。 说实话，为什么要这么搞，还是不太懂。。。（继续学习啊） 所以，用proxy来实现单例吧1234567891011const singletonify = (OriginalClass) =&gt; &#123; // 实例化class对象 let singleton = new OriginalClass() // 返回值是OrialClass，但是添加了一个功能，当new的时候，返回同一个对象singleton // construct方法用于拦截new命令 return new Proxy(OriginalClass, &#123; construct (target, args, newTarget) &#123; return singleton &#125; &#125;)&#125; 参考文献 http://es6.ruanyifeng.com/#docs/proxy https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>面试</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019.03前端月报]]></title>
    <url>%2F%2Fblog%2F2019%2F03%2F2019-03%E5%89%8D%E7%AB%AF%E6%9C%88%E6%8A%A5.html</url>
    <content type="text"><![CDATA[新闻 Chrome 浏览器支持跳转到指定文字 杨超越编程大赛项目 https://ycy.har01d.win/#/ https://www.zhihu.com/question/316762021 文章 2019 年大前端技术趋势深度解读 前端三大框架已趋于平稳，标准化，写法上也越来越像，学习成本是降低的 前端应用领域，都在思考如何选型和降低成本，基于现有技术栈的组合，封装细节，让开发者专注于业务代码 前端趋于“大前端”，不再只是 all in mobile。PWA，Flutter，WebAssembly PWA在弱网环境下表现极好，但中国的网络是全球最好的，所以 PWA 其实没有给我们带来那么大的收益 TypeScript 落地很好，包容性更好 WebAssembly 让更多语言可以运行在浏览器上，AutoCAD 的 web 版是非常好的例子 5G 时代快来了，互联网的长期在线情况有可能会被打破？ 你可能不需要SPA 传统网页： 无状态请求 浏览器知道如何处理路由、历史记录等问题 更少，更成熟的工具 SEO免费 适合SPA： 实时响应 富交互 状态分享 前端开发者必备的 Nginx 知识 没点想象力都看不透这个网站的反爬措施 工具 Handtrack.js 基于 Tensorflow.js 的手部跟踪与交互 在线制作油画的工具，可以在装修时打印出来挂在墙上 资源 现代 Javascript 教程 网页版 PPT 制作库 每月一算每月金句如果你每月在 AWS 花费10万美元，亚马逊会向你提供折扣。如果你一个月的花费超过100万美元，他们将不再理会你。因为他们知道你已经被锁在他们的服务里面，去不了别的地方。 – 《Lambda 和 无服务器将锁定你》]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈一谈单元测试]]></title>
    <url>%2F%2Fblog%2F2019%2F03%2F%E8%B0%88%E4%B8%80%E8%B0%88%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html</url>
    <content type="text"><![CDATA[引子这是我们平时的开发流程： 即：需求分析 -&gt; ui 设计 -&gt; 项目代码开发 -&gt; 编写测试用例 –&gt; 运行测试用例 -&gt; 修复代码 BUG -&gt; 上线 -&gt; 上线回测 当然，测试部分的工作有时候会提前开发，比如在需求分析、应用开发阶段就介入进来做一些工作。但是测试工作主要还是放在开发完成之后再进行。 这样子有什么问题呢： 测试时间依赖于开发时间 真正用于测试的时间，在整个项目的后期，并且严重依赖于开发时间。 当项目整体排期不变的情况下，如果开发时间 delay 了，必然导致压缩测试时间，即使测试和开发同学加班 debug，也会影响项目质量。 开发质量依赖于测试质量 开发对于代码质量也没有把握，依赖于测试的水平。 不确定新代码是否正常工作 不确定新代码是否影响别的功能 不确定重构后的代码是否正常工作 不确定重构后的代码是否影响别的功能 不确定上线后的代码是否正常工作 不确定上线后的代码是否一直正常工作 如果你的项目或你本人存在以上问题，那么你可能需要采用一些措施了。 线上监控 通过 log 日志，自动化测试，对线上环境比如数据库、服务器的性能指标进行监控，及时报警，这些策略保证了环境的问题。 代码质量 提高代码质量的方式有： 静态代码分析规范写好的代码风格，减少出错风险，不能发现 bug 代码 review人力时间成本高 单元测试 什么是单元测试定义 在计算机编程中，单元测试（英语：Unit Testing）又称为模块测试, 是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。 备注：单元测试对软件中的最小可测试单元进行检查和验证，并非检查程序单元之间是否能够合作良好 特点 独立性 单元测试用例之间不存在互相调用，也不依赖执行的先后次序，可以在多线程中并行执行。 反例：method2 需要依赖 method1 的执行，将执行结果作为 method2 的输入。集成测试里可以这么干，为了进行场景测试（先登录，后买课） 确定性 确定的输入得到肯定的输出 可重复性 单元测试可以重复执行，不依赖于特定的时间、特定的环境、特定的测试数据。在不同的机器上都能得到相同的运行结果。 这里的环境包括操作系统的类型，网络，本地文件等。说明：单元测试通常会被放到持续集成中，每次有代码 check in 时单元测试都会被执行。如果单测对外部环境（网络、服务、中间件等）有依赖，容易导致持续集成机制的不可用。正例：为了不受外界环境影响，要求设计代码时就把 SUT 的依赖改成注入，在测试时用 spring这样的 DI 框架注入一个本地（内存）实现或者 Mock 实现。 细粒度 单元规模较小，复杂性较低，粒度一般是方法级别，至多是类级别，不负责检查跨类或者跨系统的。因而发现错误后容易隔离和定位，有利于调试工作。 自动化 单元测试可以全自动执行的，并且是非交互式的，自动化的单元测试有助于进行回归测试。输出结果需要人工检查的测试不是一个好的单元测试。单元测试中不准使用 System.out 来进行人肉验证，必须使用 assert 来验证。 易用性 单元测试中用到的，无非是白盒测试中覆盖分析在内的许多测试技术。 文档性 测试用例用于测试接口、模块的重要性，那么在测试用例中就会涉及如何使用这些 API。其他开发人员如果要使用这些 API，那阅读测试用例是一种很好地途径，有时比文档说明更清晰。 本质单元测试不是目的，不是为了覆盖率达到 100%。它是一种手段，一种方法，一种规范代码编写、辅助提高代码质量的方法。 为什么要做单元测试对于单元测试的误解 单元测试应该让测试人员写 单元测试常常和编码同步进行，软件的开发者总是应当负责程序的单个单元的测试，保证每个单元能够完成设计的功能。 如果测试人员来做， 不清楚项目代码逻辑 读别人的代码尚且费劲，还要写单元测试。备注：我曾经想写精品课后台的单元测试，但是却连项目怎么运行都不清楚 代码同步不及时 让测试人员来编写单元测试，必然存在后置性。开发因为添加新功能、bugfix、重构而更新代码了，你只有在开发推送到 git 上，才知晓代码更新了。 质量无法保证 单元测试是用来保证代码质量的，一方面是保证写好的代码不出错，另一方面是保证写“好的代码”。 测试人员写单元测试，只能他去适应开发人员的代码写测试用例。他能打断开发人员的思路，让他按照自己的方式去写代码吗？ 不方便交接 本来接手别人的项目就够困难的，还要接手另一个编写的单元测试，难上加难。 单元测试没有用 编写单元测试，使我们静下心来审视、观察、思考项目，把程序设计成易于调用和可测试的，并努力降低代码的耦合度；可以提前发现代码设计中不合理的地方，减少由于错误而引起的连锁反应。 没有时间写单元测试 为什么没有时间写？ 想快点开发完代码完成项目 但是我们忘记的一点是，项目时间不仅仅依赖于开发时间，还依赖于测试时间。如果代码质量不过关的话，bugfix 阶段会让你花费时间去查原因，修复 bug，也会延长项目的整体时间。而且，当 bugfix 变成一种永无止境的任务时，从写代码中获取的兴奋感也会离你而去。 深层次原因，其实是不会写 但就像你新学一门语言一样，刚开始的时候写的慢，写长了不就快了。最好的学习方法就是动手去敲啊。而且从长期来看，写了单元测试降低了维护成本，在新需求和重构的时候不会陷入拆东墙补西墙的恐慌中，可以更自信的交出产品。 我写代码水平很高，不需要进行单元测试 人都会犯错，大神也不例外。 凡是可能出错的事就一定会出错 -- 墨菲定律 计算机按照你写出来的方式运行，而不是你想象出来的。编码不是可以一次性通过的，必须经过各种各样的测试，单元测试只是其中一种。 缺乏测试的程序代码可能包含许多 Bug，程序员在没有测试保护的情况下修改 Bug，会引发更多的 Bug，忙于除虫，于是更没有时间测试。如此循环往往会导致项目的崩溃。 为避免产生恶性循环，代码必须有一张安全网来保护，随时进行的单元测试就是这张安全网。 不管怎样，集成测试将会抓住所有的 Bug “测试金字塔”模型按照运行速度和投入成本两个维度对不同阶段的测试工作进行非常直观的可视化，可以看到单元测试是位于“测试金字塔”的最底部，很明显“单元测试”相对于其它不同阶段的测试工作，拥有速度快（运行效率），成本低（维护成本）的优势，同时也是作为上层测试工作的支撑，体现了“单元测试”的重要程度。 效率问题。举例：学习报告项目，有一个数据不显示的问题，先提给前端，前端查了是接口的问题，提给后端，后端检查代码发现是直播服务端的问题，再提给直播服务端。 集成测试的目标是把通过单元测试的模块整合在一起，构造一个具体的使用场景，通过测试发现问题。它要求项目的所有流程是走的通的。 如果测试过程中的 Bug，非常严重，阻塞测试流程，以至于不能再测试其他功能，进行错误修改，回归测试时又发现其他新的问题，使得测试工作很难开展下去。这样子会拖延项目进展。 举例：学习报告项目，集合了精品课主站、题库、客户端、前端、后台管理系统多个服务，因为某个服务的问题，导致所有流程都被 block 了。 而且，有些 bug 是集成阶段很难去 debug 的。你要去排除各种各样的原因，前端的问题还是服务端的问题，还是客户端的问题。 举例：(想个别的例子) 题库模考添加新题目，添加第三个分卷时，添加题目异常。 单元测试不需要维护 一年半载后，那么单元测试几乎处于废弃状态。 单元测试与线上故障没有辩证关系 好的单元测试能够最大限度地规避线上故障。 单元测试保障一切 单元测试不是万能的，单元测试只是测试代码功能，不包含复杂的业务逻辑。 举例：登录逻辑没有问题，但用错接口服务了（测试服）。这个单元测试就发现不了了。 单元测试的意义：对于整个项目单元是整个软件的构成基础，单元测试是整个软件质量的基础。 就像硬件系统中的零部件一样，只有保证零部件的质量，这个设备的质量才有基础。因此，单元测试的效果会直接影响软件的后期测试，做好单元测试，后期的系统集成联调或集成测试和系统测试会很顺利，节约很多时间，最终在很大程度上影响到产品的质量。 对于开发人员 提高架构能力 编写单元测试将使我们从调用者的角度观察、思考，特别是要先考虑测试，这样就可把程序设计成易于调用和可测试的，并努力降低软件中的耦合，使得代码清晰、易于阅读，提高可维护性。在开发过程中进行测试，可以提前发现代码设计中不合理的地方，提高代码的配置性，可扩展性。比开发完再被叫去修 bug 要快许多，便于项目维护。 减少失误 增加新功能的时候，往往一改一大片。加入单元测试，这种修改幅度让你很难写测试。单元测试强迫你降低修改幅度，每次一点一点的修改。 保证重构 互联网行业产品迭代速度很快，没有一成不变的代码，迭代后必然存在代码重构的过程，后续任何代码更新也必须跑通单元测试用例，保障预期功能的实现，也不会对其他功能产生干扰。 上线不慌 之前每次上线都小心翼翼，生怕修改之后，不符合原来的要求。单元测试用例能给你一颗定心丸。 为什么要做单元测试？ 我们想要代码运行起来 我们想要代码持续运行起来 我们想要有更多的自信，更少的重写 因为我们都会犯错 因为开源大项目都有单元测试 javascript:https://github.com/vuejs/vuehttps://github.com/facebook/react java：https://github.com/spring-projects/spring-boothttps://github.com/spring-projects/spring-frameworkhttps://github.com/apache/cassandrahttps://github.com/apache/incubator-dubbohttps://github.com/spring-cloud-incubator/spring-cloud-alibaba c:https://github.com/antirez/redis python:https://github.com/google/ggrc-core dart:https://github.com/flutter/flutter 什么时候做单元测试并不是所有的项目都值得引入测试框架，也不是任何时刻都可以写单元测试，毕竟维护测试用例也是需要成本的。 不适合 需求频繁变更、复用性较低的内容 比如活动页面，让开发专门抽出人力来写测试用例确实得不偿失。 刚刚接手的老项目 老项目能够运行起来就很不错了，更不用说修改代码，这个要慢慢来重构。 不再更新，运行稳定的老服务 不再维护，准备重构、放弃的项目 适合 新框架、新服务、新项目 基础服务、通用组件 被多次复用的部分，比如一些通用组件和库函数，更要测试来保障代码可维护性、功能的稳定性。给它们写单元测试用例，维护成本低。 核心业务、核心应用、核心模块 支付、登录、退款。。。 怎么做单元测试TDD（Test-driven development）：介绍一下 TDD，测试驱动开发是敏捷开发中的一项核心实践和技术，也是一种设计方法论。测试驱动开发的基本思想就是通过测试来推动整个开发的进行，在开发功能代码之前，先编写测试代码。也就是说在明确要开发某个功能后，首先思考如何对这个功能进行测试，并完成测试代码的编写，然后编写相关的代码满足这些测试用例。然后循环进行添加其他功能，直到完全部功能的开发。 单元测试的首要目的不是为了能够编写出大覆盖率的全部通过的测试代码，而是需要从使用者(调用者)的角度出发，尝试函数逻辑的各种可能性，进而辅助性增强代码质量 测试是手段而不是目的。测试的主要目的不是证明代码正确，而是帮助发现错误，包括低级的错误。 开发流程 明确当前要完成的功能。可以记录成一个 TODO 列表 需求分析，思考实现。考虑如何“使用”产品代码，是一个实例方法还是一个类方法，是从构造函数传参还是从方法调用传参，方法的命名，返回值等。这时其实就是在做设计，而且设计以代码来体现。 快速完成针对此功能的测试用例编写 只关注需求，程序的输入输出，不关心中间过程 测试代码编译不通过 编写对应的功能代码 不考虑别的需求，用最简单的方式满足当前这个小需求即可 测试通过 对代码进行重构，并保证测试通过。 循环完成所有功能的开发。 写完，手动测试一下，基本没什么问题，有问题补个用例，修复。 最终符合所有要求即： 每个概念都被清晰的表达 代码中无自我重复 没有多余的东西 信心满满地提交，通过测试 更概括的来说，可以分为三部曲: 红灯（代码还不完善，测试挂）-&gt; 绿灯（编写代码，测试通过）-&gt; 重构（优化代码并保证测试通过） TDD 的本质 分离关注点，一次只戴一顶帽子 在我们编程的过程中，有几个关注点：需求，实现，设计。TDD 给了我们明确的三个步骤，每个步骤关注一个方面。红：写一个失败的测试，它是对一个小需求的描述，只需要关心输入输出，这个时候根本不用关心如何实现。绿：专注在用最快的方式实现当前这个小需求，不用关心其他需求，也不要管代码的质量多么惨不忍睹。重构：既不用思考需求，也没有实现的压力，只需要找出代码中的坏味道，并用一个手法消除它，让代码变成整洁的代码。 注意力控制 人的注意力既可以主动控制，也会被被动吸引。注意力来回切换的话，就会消耗更多精力，思考也会不那么完整。 使用 TDD 开发，我们要主动去控制注意力，写测试的时候，发现一个类没有定义，IDE 提示编译错误，这时候你如果去创建这个类，你的注意力就不在需求上了，已经切换到了实现上，我们应该专注地写完这个测试，思考它是否表达了需求，确定无误后再开始去消除编译错误。 单元测试的本质我不是强制向大家推行 TDD，说实话 TDD 很复杂，不是一句两句就学会的，何况我也没什么经验。我们要借鉴 TDD 的思想，那就是写代码之前，先别急着动手，先想。考虑周全了再写。这个时候，即使先写功能，再写测试也是没问题的。一定不要把功能都写完了，再补测试，你会发现很痛苦。可能为了某个测试用例的写法，需要重构你的代码，这样子就相当于花费了更多的精力。 拆分项目TDD 之前要拆分任务，把一个大需求拆成多个小需求。 原则 结合设计文档，关注于完成当前功能点，防止过度设计 仅凭这个就可以节省大量精力了。那些仅仅是“可能”会发生的事情，我们不会去做。过多的考虑后期的扩展，其他功能的添加，无疑增加了过多的复杂性，容易产生问题。 单元测试不仅是证明这些代码做了什么，是如何做的，而且证明是否做了它该做的事情而没有做不该做的事情。 （小字）拆分不是让我们把任务想的非常全，在后续兼容上方便。后续添加的时候，一看，哎，我之前想到了，这里留着参数等着用。万一用不着呢？那不就浪费时间了嘛。 那么需求真的变了怎么办？改呗。有整套测试用例做基础，会让应对变化变得容易，但它会让你有底气去做出修改。 还是那句话，天下武功，唯快不破，改得越快，成本越低。 任务维持在单元级别 当前功能太过复杂，继续分解成小的任务来完成。 举例：既要获取用户个人信息，又要获取用户购课信息。 单元测试工欲善其事必先利其器测试框架 Java: Junit, TestNG Javascript: Jest, Mocha Android/Kotlin: Junit Swift: XCTest Python: Unittest C++: gtest Go: go test 覆盖率分析 Java: Emma, Jacoco Javascript: istanbul(Jest 内置) Python: Coverage.py C++: LCOV 常用的覆盖率 语句覆盖率/行覆盖率 语句覆盖指被测单元中每条可执行语句都被测试用例所覆盖。语句覆盖是强度最低的覆盖要求 分支覆盖率 用来度量程序中每一个判定的分支是否都被测试到，即代码中每个分支语句取真值和取假值至少各覆盖一次 函数覆盖率 覆盖率只是单元测试的一种衡量标准，一种基于定量的衡量标准，不足以说明测试的稳健性。不要过度追求覆盖率，100%的覆盖率不代表你的代码就没有问题了。统计代码覆盖率的目的是找出哪些类型的代码未经过测试，并针对性的补充测试用例。 就像那些正在出差并出示护照印章的人一样 - 这并不能证明他做过任何工作，只是他访问过几个机场和酒店。 1234567891011function addNewOrder(newOrder) &#123; logger.log(`Adding new order $&#123;newOrder&#125;`); DB.save(newOrder); Mailer.sendMail(newOrder.assignee, `A new order was places $&#123;newOrder&#125;`); return &#123;approved: true&#125;;&#125;it("Test addNewOrder, don't use such test names", () =&gt; &#123; addNewOrder(&#123;asignee: "John@mailer.com",price: 120&#125;);&#125;);//Triggers 100% code coverage, but it doesn't check anything 断言库 Assert有的语言还有单独的断言库，有的自带了。 Mock 框架mock 就是在测试过程中，对于某些不容易构造或者不容易获取的对象，用一个虚拟的对象来创建以便测试。 LintLint 是检查代码风格/错误的小工具，作用是提高代码质量。 Javascript 编写有 eslint, 而单元测试编写有 eslint-plugin-jest, eslint-plugin-mocha 持续集成 Travis-ci Jenkins 单元测试原则测试隔离 不同代码的测试应该相互隔离 单元测试之间没有依赖关系 对一个代码单元只考虑此代码的测试 不考虑第三方调用不考虑内部方法不考虑子类 // todo:代码片段例：react 中父子组件之间/一个函数调用了其他函数/controller 和 service 12345function A(value) &#123; const a = 10 const b = B(value) return a + b &#125; 输入输出 数据尽量使用真实数据、边界数据 不要用随机数，使用确定的数值 不要使用开发代码里的命名常量 他们可能是错误的，可能会更改 不要共享全局数据，否则一个出错会导致多个测试用例出错（?） 定义好时间（跨时区问题）、光速、重力等物理常量 不要在单元测试里做逻辑问题（条件、选择逻辑） 把他们写到多条单元测试里 在合适的位置使用合适的注解 一个单元测试里只有一个 assert 通过的测试不产生任何输出 未通过的测试只产生必要的输出 不要为了通过一项测试用例, 而写一个无意义的测试, 比如仅有一句 assert(true) 在测试中使用适当的 Mock 技术 可以降低测试的相互依赖性, 更快速的编写测试用例. 一般的 Mock 对象包括: 数据库, 其他产品和服务等.避免在测试代码中使用基类, 即尽量不要有过多的继承层次. 目的是保持测试代码的简洁易读, 无依赖性 环境 不要访问网络 不要访问文件系统 不要访问预设的外部资源 单元测试代码不应该假定外部的执行环境, 以便在任何时候/任何地方都能执行. 为了向测试提供必需的资源, 这些资源应该由测试本身提供. 比如一个解析某类型文件的类, 可以把文件内容嵌入到测试代码里, 在测试的时候写入到临时文件, 测试结束再删除, 而不是从预定的地址直接读取. 执行 一个单元测试应该在 1s 内完成 一组测试集应该在 1 分钟内完成 把一个大的测试集分成多个小的测试集 把执行最慢的用例放在最后执行 更新代码时测试列表。需要测试的功能点很多。应该在任何阶段想添加功能需求问题时，把相关功能点加到测试列表中，然后继续手头工作。然后不断的完成对应的测试用例、功能代码、重构。一是避免疏漏，也避免干扰当前进行的工作。 生产环境或发布版本中不能带有测试代码单元测试方法命名习惯测试代码 Package 的命名和结构应该保持和实现代码的保持一致. 这样可以提高测试代码的可维护性 测试代码与开发代码隔离 许多构建和测试工具都需要将测试代码放在一个特定的源码目录中. Maven 和 Gradle 默认 src/main/java 中是实现代码, 而 src/test/java 中是测试代码. 实现代码和测试代码的包名结构保持一致 测试类的命名和实现类命名有规律 通常是用 Test 或其他类似词汇作为前缀或后缀// todo:截图比如 src/controller/Login.java test/controller/Login.test.java 使用有意义的测试用例名称, 要能够大致描述测试的对象或行为。 每个测试名称包含 3 个部分 （1）正在测试什么？例如，ProductsService.addNewProduct 方法 （2）在什么情况和情况下？例如，没有价格传递给方法 （3）预期结果是什么？例如，新产品未获批准 好的测试报告类似于需求文档 123456describe('ProductsService', function() &#123; // testsuite测试用例集 it('addNewProduct, when no price is specified, then the product status is pending approval', ()=&gt; &#123; // testcase测试用例 const newProduct = new ProductService().add(...); expect(newProduct.status).to.equal('pendingApproval');// assert &#125;);&#125;); 测试技术在单元测试时要根据“白盒”测试和“黑盒”测试用例设计方法设计测试用例 黑盒测试等价类划分法 边界值分析法 错误推测法 因果图法 功能图法 白盒测试主要是逻辑驱动法和基本路径法 语句覆盖。判定覆盖。条件覆盖。判定/条件覆盖。条件组合覆盖。路径覆盖。 等级 Level1：正常流程可用，即一个函数在输入正确的参数时，会有正确的输出正确的输入，并得到预期的结果 Level2：异常流程可抛出逻辑异常，即输入参数有误时，不能抛出系统异常，而是用自己定义的逻辑异常通知上层调用代码其错误之处强制错误信息输入（如：非法数据、异常流程、非业务允许输入等），并得到预期的结果。 Level3：极端情况和边界数据可用，对输入参数的边界情况也要单独测试，确保输出是正确有效的边界值测试，包括循环边界、特殊取值、特殊时间点、数据顺序 Level4：所有分支、循环的逻辑走通，不能有任何流程是测试不到的 Level5：输出数据的所有字段验证，对有复杂数据结构的输出，确保每个字段都是正确的 单元测试的实施规则 安排测试优先次序，核心业务、核心应用、核心模块的增量代码确保单元测试通过。 说明：新增代码及时补充单元测试，如果新增代码影响了原有单元测试，请及时修正。 单元测试的基本目标：语句覆盖率达到 70%；核心模块的语句覆盖率和分支覆盖率都要达到 100% 高的代码覆盖率不一定能保证代码的质量，但是低的代码覆盖率一定不能保证代码的质量。 对于不可测的代码建议做必要的重构，使代码变得可测，避免为了达到测试要求而书写不规范测试代码。 在设计评审阶段，开发人员需要和测试人员一起确定单元测试范围，单元测试最好覆盖所有测试用例。 单元测试作为一种质量保障手段，不建议项目发布后补充单元测试用例，建议在项目提测前完成单元测试。 所有的测试都必须通过：这一点很重要，不能因为懒惰而产生 Failed 掉的 Case。 最简单的测试也远远胜过完全没有测试。 总结单元测试写起来不容易，且写且珍惜。 参考文献： https://www.youtube.com/watch?v=fr1E9aVnBxw https://github.com/yangyubo/zh-unit-testing-guidelines https://medium.com/@me_37286/yoni-goldberg-javascript-nodejs-testing-best-practices-2b98924c9347 https://www.jianshu.com/p/62f16cd4fef3 https://www.ibm.com/developerworks/cn/linux/l-tdd/index.html https://juejin.im/entry/5b485e186fb9a04f8a2177a5 https://www.jianshu.com/p/f18cf0ea72ec https://github.com/linesh-simplicity/linesh-simplicity.github.io/issues/84 https://github.com/Chunlin-Li/Chunlin-Li.github.io/blob/master/blogs/java/java-test.md]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发、测试趣谈]]></title>
    <url>%2F%2Fblog%2F2019%2F03%2F%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95%E8%B6%A3%E8%B0%88.html</url>
    <content type="text"><![CDATA[开发和测试是互联网公司最常见的两个工种，他们相互依赖，或者说单方面依赖，但至少不像开发和产品那样关系恶劣，动不动就武力解决。网上关于开发、产品关系的段子很多，但关于开发和测试的却不多。因为工作关系，对开发、测试都比较熟悉，所以今天我们来聊一聊开发和测试之间的那些事儿。 角色定位开发：就像是建筑师一样，按照图纸的要求，打地基盖房子，尽可能100%还原设计师的要求。开发自测的思路也一般以完成功能为主，想的是正常人应该的操作（但用户是正常人吗？) 测试：对测试过程充满了期待，他们像一群拆迁队一样，疯狂的在项目上做着破坏，寻找bug。比如，一个住人的房子，测试是这么测的： 这房子能住1个人吗? 这房子能住0.6个人吗？ 这房子能住-1个人吗？ 这房子能住100亿个人吗？ 这房子能住NULL个人吗？ 这房子能住1头猪吗？ 这房子能住一个asdfQwer@24dg!&amp;*(@吗？ 这房子能住一个烫烫烫的锟斤拷吗？ 这房子拆了天花板能住人吗？ 这房子剩一半能住人吗？ 这房子只剩个天花板能住人吗？ 把这房子挪到别的地方能住人吗？ 这房子有一万个人一起涌进来，然后又走了，之后还能住人吗？开发：😅，用户不会像你这么操作的 他们以发现bug的数量和质量为荣，他们给开发报bug的时候，多半是很开心的。 但是，bug数太多测试：这个开发，这次又有100多bug，也不害臊开发：呵呵… 当找bug变成一种似乎永无止境的任务时，找bug的快感就完全消失了。 提测开发：排期定好了，到提测时间了，可我代码还没写完呢，怎么办？先把主流程写通吧，小细节，测试同学测的时候我继续开发，提bug就提bug吧。 测试：提测了，那应该是都写好了，流程是可以跑通的。 提测申请开发：哎呀，为什么这个模板里有这么多内容，我要写那么多干嘛，就写个标题吧，嘿嘿 测试：你不写全了，我哪知道需要测试啥？你的代码你最清楚啊 相关prd、接口、log文档呢 哪个地方应该重点测试 哪个地方的逻辑有些复杂 是否有权限要求，在哪申请 是否修改了prd上没有的功能 测试服地址，app哪些模块需要连接测试服 bug测试：发现了一个bug，跟开发说：这里运行不了，是不是有bug？开发：呵呵，你的环境没搭好吧？ 资深测试：发现一个bug，跟开发说：亲，我这里运行不了，能不能帮忙看看是不是我环境没搭好？开发：卧槽，是不是出bug了？ 测试写的bug说明测试：我费了劲在jira写了半天开发：我就看个标题 开发：复现步骤呢，bug环境呢，链接呢，机型呢？有截图吗？测试：… 有经验的测试，不会一发现问题，就给开发提bug。而是进行反复的确认，在测试报告里会写出详细的复现步骤，贴出效果图，确认bug的产品环境(比如，是任何机器都会触发，还是某台特定机器特定浏览器的问题)。 再资深一点的测试，会主动追查bug产生的原因，会去代码的相关片段进行debug，给出开发同学合适的建议。 debug开发：debug的心态，则是一个变化的过程。 不可能，我代码写的那么好，怎么会有bug 哎，我电脑上是好好的啊 真是奇怪，刚刚还好好的 肯定是数据问题 清下缓存试试 重启电脑试试 我去，居然忘加判断了，真傻x 不对，不是我的问题，这是之前那个傻x写的 哦，这个地方就得是之前的写法，是我傻x了 哎呀，找到问题了，跟我没关系，是锅，又背锅了 不是自己写的bug开发同学：不是我的锅，是第三方包/后端/客户端/之前那个傻x的问题 测试同学：我不管，是你的项目的问题，就是你的bug 重复提的bug开发：两位测试大大，你俩能不能同步一下再报bug，我的bug数破100了测试：… 开发：这几个bug都是一个问题引起的，唉，怪我自己。。。 debug过程中出现的bug开发：哎呀，这个地方的逻辑写的不对，趁测试没发现，偷偷改了。改完之后，一看jira，呵呵，那个bug刚刚提交出来。测试：没有我发现不了的bug 需求变动测试：这个地方怎么跟prd不符？ 开发：产品需求改了啊，怎么没改prd两人一起怒视pm 开发：emmmm，我觉着这么做更符合用户使用习惯（其实是实现起来麻烦，换了一种方式） 改完bug开发：默默改完了测试：改完了吗？在吗？人肉访问中。。。 测试：改完了吗？你改一下jira状态啊？ 测试：改完了？自测了吗？还是有问题啊？开发：WTF… 复现步骤太麻烦了，就在脑子里过了一遍逻辑，感觉没问题 没切回原来的环境 没删断点log 测试：改完了，能告知一下错误原因吗？ 要封包了，还要改需求的pm开发、测试双双拿起来桌子上的板砖 上线开发：我就改了一点点，不影响其他功能，不用测了，直接上吧测试：上线了？什么时候上的？上的什么功能，我不知道怎么能上线，出问题不要甩锅给我啊！！！ 不要偷偷上线，有时间尽量安排测试。实在不行，也要跟测试同学同步一下信息。 线上故障开发：你们测试怎么回事，怎么没测出来？测试：你没跟我说这个需求啊，我哪知道？测试：对不起，我尽力了。。。 世上没有无bug的代码，开发尽量不写带明显bug的代码；测试要写测试用例，要维护核心case。 开发测试是一个团队，大家都是为了一个目标，所以要相亲相爱，要peace!]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】我是一个平庸的程序员]]></title>
    <url>%2F%2Fblog%2F2019%2F02%2F%E6%88%91%E6%98%AF%E4%B8%80%E4%B8%AA%E5%B9%B3%E5%BA%B8%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%98.html</url>
    <content type="text"><![CDATA[12原文链接：https://dev.to/sobolevn/i-am-a-mediocre-developer--30hn作者：@Nikita Sobolev 我个人认为有一些程序员就是天才，他们可以轻而易举地创造一些了不起的软件产品。因为这群天才的存在，我们对这个行业充满了期待。但是有一个悲伤的事实是：不是每一个人都是大师级的程序员。 实际上这就是我，一个平庸的程序员。这篇文章将指导你，作为一个非天才程序员，如何在这个行业中生存。 我一直用google搜索最简单的技术我记不住很多东西。比如，标准库里的函数和方法，参数的位置，依赖的包名，样板代码等等。 所以，我需要用google搜索。而且，我每天如此。而且，我也从旧的项目里复用代码，有时也从StackOverflow或者GitHub上复制别人的代码。是的，我是一个面向StackOverflow编程的程序员。 但我不是一个人在战斗，很多很多程序员都像我一样。Ruby on Rails的作者曾经发过一个很火的twitter。 这样子写代码有什么不好呢？有如下几点坏处： 你可能从别人那拷贝的，是糟糕的设计或者很烂的代码。 容易形成一个坏的心态：如果不能从网上搜索到你想到的，那么就是“休斯顿，我们遇到麻烦了”。 如果没有网了，那么你就无法工作了。 但是，我并不认为这是一个大问题。它甚至可以作为你的秘密武器。我有几点建议减轻这些负面影响。 生存法则1 使用IDE的代码自动补全和提示，你就不用去搜索语言的基础用法了。 记住你在什么地方或使用什么方法解决了这个问题。下一次遇到同样的问题，找出来看一下就可以了。 你提交到项目中的所有代码，都应该在之后进行分析、重构和评审。这样做，就不会用糟糕的代码降低项目的质量，而是帮助它获得快速的解决方案。 保存事情的简单性我们说什么，机器做什么。有时候，机器做了错误的事情，仅仅是因为我们下了错误的指令。因此软件开发中的主要问题，不是机器，而是开发人员的思维能力。这种能力是有限的。所以，我们作为一个平庸的程序员，不要浪费脑子去创建复杂的抽象设计、编写晦涩的算法或不可读的长代码块。保持简单性。 然而，我们怎么区分这段代码是简单的还是复杂的？我们需要使用WTFs/分钟的方法去衡量代码质量。（译者注：WTF = What the Fu**） 这条规则非常简单易懂。你发现代码中有一些你看不懂的东西，那它就是复杂的。你应该怎么做？ 重写代码，让人看起来清晰 提供文档 在最难懂的地方添加注释。但是记住，过多的注释本身，就是代码的坏味道。（译者注：参见22种代码味道） 生存法则2(怎样开始编写简单的东西) 使用正确的变量名、函数名和类名 确保你代码每一部分只做一件事件 优先使用纯函数，而不是常规函数 优先使用常规函数，而不是类 只在非常必要的情况下，才使用回调 我不相信我自己一些开发者已经证明他们能提交高质量的代码。像下面这位女神：Margaret Hamilton，阿波罗计划的首席软件工程师。这张图里，她旁边的等身高的纸，就是为登月任务编写的代码。 不过，但于我而言，无论我编写任何代码，我不相信我自己。即使是做项目里最简单的部分，我也能把事件搞得非常糟糕，可能包括： 语言错误 逻辑错误 设计错误 演示错误 安全性错误 WTF错误（我最喜欢的） 世界上并没有一本关于“如何编写无bug代码”的魔法师，所以这些错误都是正常的。所有的软件都有bug，处理掉它就是了。 实际上，任何人都不允许编写带有明显错误的代码。所以至少我们应该尝试做到这一点。我应该怎样保护我自己的项目呢？下面有几条建议。 生存法则3 编写测试用例，编写大量的测试用例。大到集成测试，小到单元测试。在每次拉取请求前执行CI持续集成，这将减少你的一些逻辑错误。 使用静态数据类型或者可选静态类型。例如，我们在python中使用mypy，在javascript中使用flow（译者注：现在应该使用Typescript）。这样做的好处是：清晰的设计和编译时类型检查。 使用自动样式检测工具。每种语言都有大量的样式检查工具。 使用质量检测工具。有些工具在你的代码库上运行一些复杂的启发式算法来检测不同的问题，比如这行内部逻辑太多，不需要这个类，这个函数太复杂。 检阅你的代码。在合并到主分支之前代码，有时候在合并之后也需要review。 花钱让别人审核你的代码。这样做有相当大的好处，因为当别的程序员第一次看你的代码时，很容易看出不一致的地方和糟糕的代码设计。 不应该只在我的电脑上有效 差不多十年前，当我的团队开发完第一个大型软件项目时，我们将其作为java源文件发布。在我们呈现给客户前的几个小时，它在目标服务器上编译失败了。这算是个大事故。虽然最终我们修复好了并运行起来，但这是个终身难忘的经历。 这是因为在构建管道里，有着大量的配置和大量的复杂性。我们没有能力去正确管理该系统的复杂性。从那天开始，为了减少这一步的复杂性，我尝试将程序打包在独立的环境中，并在实际部署之前在此环境中进行测试。 这几年，随着docker（以及一般的容器）的兴起，这件事情开始变得简单起来。docker允许你在完全相同的独立环境下进行开发、测试和生产上线。采用这种方式，你不会遗留任何重要的事情。 不好吗？说说我自己，在搭建服务、初始化配置或者链接一些东西的时候，我总会遗漏掉一部分。因为有许多东西需要记住。幸运的是，我们仍然可以实现自动化。有许多很棒的工具可以进行自动化部署。如：terraform, ansible, and packer。查看他们的文档，找到适合你的工具。 我也尝试设置CI/CD进行持续集成和持续部署。当在测试和部署的自动化构建失败时，我会收到报告通知。 生存法则4 一切使用自动化部署 使用docker作为开发、测试和生产环境 使用部署工具 在部署应用后，我仍然不相信我自己最后，我的应用已经在生产环境上线了，它已经在运行了。我可以打个小盹儿了，什么事儿都不会发生。等一下，不，一切都将崩溃。是的，一切。 实际上，有一些工具可以很容易的发现和修复现在问题。 Sentry. 任何一个你的用户产生异常时，你都会收到通知。Sentry已经支持几乎所有的开发语言。 各式各样的服务和工具，可以将多个程序的日志收集到一个地方。 服务监控.你可以对CPU、硬盘、网络和存储器配置监控。你甚至可以在用户实际压垮你的服务之前，确定需要进行服务扩容的时间。 简单来说，我们需要在生产环境上进行监控。有的时候你需要上述所有工具，有的时候你只需要一部分。要根据自己的情况进行判断。 持续学习哇，有好多需要学的东西。但这就是我的生存方式。如果我们想写好代码，我们就需要持续学习。成功路上没有捷径，你需要做的就是学习如何一天比一天好。 总结来说，我们需要理解两个基本原则： 每个人都会遇到问题。最关键的是，我们对这些问题，准备好了吗，准备到什么程度。 我们可以把问题的根源降低到可接受的程度。 这与你的思维能力或心态无关。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas图片如何旋转90度]]></title>
    <url>%2F%2Fblog%2F2019%2F01%2Fcanvas%E5%9B%BE%E7%89%87%E6%97%8B%E8%BD%AC%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[canvas如何实现将一张图片旋转90度的效果呢？ 方法1：修改canvas的css，将canvas旋转90度index.html123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; body &#123; margin: 0px; padding: 0px; &#125; canvas &#123; border: 1px solid red; margin-bottom: 150px; display: block; &#125; #myCanvas2 &#123; transform: rotate(90deg); &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id="myCanvas"&gt;&lt;/canvas&gt; &lt;canvas id="myCanvas2"&gt;&lt;/canvas&gt; &lt;script&gt; var canvas = document.getElementById('myCanvas') var context = canvas.getContext('2d') var canvas2 = document.getElementById('myCanvas2') var context2 = canvas2.getContext('2d') var imageObj = new Image() imageObj.width = 440 imageObj.height = 302 var width = imageObj.width var height = imageObj.height imageObj.onload = function() &#123; canvas.width = width canvas.height = height canvas2.width = width canvas2.height = height context.drawImage(imageObj, 0, 0) context2.drawImage(imageObj, 0, 0) &#125; imageObj.src = 'https://www.html5canvastutorials.com/demos/assets/darth-vader.jpg' &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 缺点： 仅仅是从视觉上将图片旋转了，但如果将图片导出，获取到canvas2.toDataURL(‘image/png’)，图片仍然是正常的，而不是旋转之后的。 方法2：canvas不变，将图片旋转90度12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; body &#123; margin: 0px; padding: 0px; &#125; canvas &#123; border: 1px solid red; margin-bottom: 50px; display: block; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id="myCanvas"&gt;&lt;/canvas&gt; &lt;canvas id="myCanvas2"&gt;&lt;/canvas&gt; &lt;script&gt; var canvas = document.getElementById('myCanvas') var context = canvas.getContext('2d') var canvas2 = document.getElementById('myCanvas2') var context2 = canvas2.getContext('2d') var imageObj = new Image() imageObj.src = 'https://www.html5canvastutorials.com/demos/assets/darth-vader.jpg' imageObj.width = 440 imageObj.height = 300 var width = imageObj.width var height = imageObj.height imageObj.onload = function() &#123; canvas.width = width canvas.height = height canvas2.width = height canvas2.height = width context.drawImage(imageObj, 0, 0) context2.translate(canvas2.width / 2, canvas2.height / 2) context2.rotate(Math.PI * 90 / 180) context2.drawImage(imageObj, -canvas2.height / 2, -canvas2.width / 2) context2.rotate(-Math.PI / 2) context2.translate(-canvas2.width / 2, -canvas2.height / 2) &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; canvas api translate(): 重新映射画布上的 (0,0) 位置 rotate(): 方法旋转当前的绘图 要想理解这两个用法，就需要清楚转换之后的坐标位置，参考这篇文章 原理 先将ctx坐标移至canvas中心 旋转ctx90度，改变坐标系位置 将图片在坐标系的负1/2处渲染出来 将ctx坐标恢复默认 注意:图片在canvas中的渲染，一定要放到imageObj.onload中，否则可能会出现渲染出来的图片为空，因为imageObj尚未加载完成。 掌握了这个旋转方法，在literallycanvas中的图片旋转就变得很简单了 参考我的代码]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>知识点</tag>
        <tag>Canvas</tag>
        <tag>备忘</tag>
        <tag>Literallycanvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018前端年终盘点]]></title>
    <url>%2F%2Fblog%2F2019%2F01%2F2018%E5%89%8D%E7%AB%AF%E5%B9%B4%E7%BB%88%E7%9B%98%E7%82%B9.html</url>
    <content type="text"><![CDATA[年度盘点系列 前端 2018 解读 2018年GitHub年度盘点（中文链接） 2018年JavaScript生态圈调查报告出炉！（中文链接） New ES2018 Features Every JavaScript Developer Should Know (中文链接) 剩余参数和扩展运算符 异步迭代 Promise.finally 正则表达式 标记模板文字 The Most Liked CodePen Examples in 2018 知识点 Node.js和JavaScript测试最佳实践 redux作者Dan Abramov不知道的事 1234567不管你的程度多好，你仍会感到不安或毫无自信。虽然经验丰富的开发者也有很多不会的东西，但他们仍拥有十分宝贵的专业与技术。我知道我的知识缺口是哪些（至少是某些）。我可以在未来我感到好奇或需要它们的时候补强这些不足。而这个认知并不会抹煞我的知识与经验。有很多事情是我可以做得很好的。例如：在我需要某个技术的时候，把它学起来。 如何用svg画一个进度环]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重构一时爽...]]></title>
    <url>%2F%2Fblog%2F2019%2F01%2F%E9%87%8D%E6%9E%84%E4%B8%80%E6%97%B6%E7%88%BD.html</url>
    <content type="text"><![CDATA[俗话说的好，“重构一时爽，全家火葬场”。这两天就遇到了这么个事。 本来一个老项目要加一点新需求，挺简单的事，前端一两天就干完了。偏偏遇到了后端大佬把接口重构了，接口名、请求参数、请求方式、返回数据都有变化，这可就有的忙了，光重构就重构了好久。 要说光改改接口，返回结果格式，也问题不大，稍微麻烦一点吧，多弄两天也就ok了。偏偏遇到自己这时候强迫症犯了，把之前项目写的不好的地方又重新整了一遍。原先的项目路由一直设置的不好（前人历史遗留问题），参数全部用的search格式，导致每次数据变化了都要用componentWillReceiveProps来进行判断，不仅判断起来复杂，还会导致render执行多次，造成浪费，而且debug起来也很麻烦。索性改了，引发关键数据变化的参数统统改成router pathname，这样子数据变化的时候只需要判断componentDidMount或者componentDidUpdate就可以了。 这样子就相当于将整个项目都重写了一遍，又花了大几天的时间。如果到这了，也就ok。偏偏让我看到了antd的版本还停留在2.x时代，这antd都已经更新到3.11.6（重构项目的时候，刚才我又看了一眼antd的更新日志，已经到3.12了。）怎么办，升级呗，升完了感觉确实好看一点点了。 到这里感觉应该差不多了吧，嗯。。。，这个ui界面长得还是丑了点。纯粹是产品画了张草图，开发自己随便方便着来的布局，没有一点点的美感。虽说这是个内部系统，可以也太不好看了吧。用antd-pro重写一遍？杀了我吧，实在是改不动了。 虽然不能用antd-pro来重写，但antd-pro的页面布局可以考虑一下啊，找demo里合适的布局样式来改了改。嗯，改完了还挺好看的，终于有点高大上的感觉了。完结撒花！！！ 有人要问了，你这么搞不是多花了好多的工作时间，导致项目周期延长吗？错了，这也是为啥说重构一时爽的原因了。在不影响项目周期的前提下，进行自我认同的重构工作，都是在下班时间搞的。就像现在这个，元旦假期搞了好几天呢，甚至还通了个宵，隐隐的感觉到了身体被掏空。。。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo next主题配置]]></title>
    <url>%2F%2Fblog%2F2018%2F12%2Fhexo-next%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[站在巨人的肩膀上，提供一下链接： next官方文档 搭建hexo 百度统计配置 阅读人数配置 字数统计、阅读时长配置 工具 来必力评论系统 百度统计 leancloud阅读人数统计]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux-thunk的原理解析]]></title>
    <url>%2F%2Fblog%2F2018%2F11%2Fredux-thunk%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"><![CDATA[参考文档：redux-thunk的原理解析 个人理解：1、首先了解redux的中间件原理const store = createStore(reducer, applyMiddleware(thunk))在createStore的时候，如果应用了中间件，那么store的属性dispatch、getState可能会被重写而在redux-thunk中，dispatch就被重写了2、redux-thunk 1234567891011121314function createThunkMiddleware(extraArgument) &#123; return (&#123; dispatch, getState &#125;) =&gt; next =&gt; action =&gt; &#123; if (typeof action === 'function') &#123; return action(dispatch, getState, extraArgument); &#125; return next(action); &#125;;&#125;const thunk = createThunkMiddleware();thunk.withExtraArgument = createThunkMiddleware;export default thunk; 应用了redux-thunk后，dispatch变成了一个可以传function参数的dispatch，当遇到action为function时，执行该function的action，如果是正常的action，则执行dispatch 12345678dispatch=function(store.dispatch)&#123; action =&gt; &#123; if (typeof action === 'function') &#123; return action(store.dispatch, getState, extraArgument); &#125; return store.dispatch(action); &#125;; &#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>源码</tag>
        <tag>React</tag>
        <tag>Redux-thunk</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科里化]]></title>
    <url>%2F%2Fblog%2F2018%2F11%2F%E7%A7%91%E9%87%8C%E5%8C%96.html</url>
    <content type="text"><![CDATA[bind的概念 12var result = fun.bind(thisArg[, arg1[, arg2[, ...]]]) result(newArg1, newArg2...) bind返回一个新的函数，这个函数要绑定的this对象指向第一个参数，后面的参数是传入新函数的参数。这个函数的功能和fun函数的功能一样。所以，上面的bind函数可以等价于：1result(newArg1, newArg2...) = thisArg.fun(newArg1, newArg2...) 科里化的概念 1）科里化的目的123把func(arg1, arg2, arg3...)类型的函数转换成func(arg1)(arg2)(arg3)(...)类型 2）科里化的返回值 所以科里化的返回值仍然是一个函数，这样才能继续执行后面的参数(arg2)(arg3)(…) 3）科里化的定义 将函数与其参数的一个子集绑定起来后返回个新函数。 所以要绑定，就需要bind方法 4）科里化的实现1234567var currying = function(fn) &#123; var args = [].slice.call(arguments, 1); return function() &#123; var newArgs = args.concat([].slice.call(arguments)); return fn.apply(null, newArgs); &#125;;&#125;;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>知识点</tag>
        <tag>curry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React单元测试实战]]></title>
    <url>%2F%2Fblog%2F2018%2F10%2FReact%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%AE%9E%E6%88%98.html</url>
    <content type="text"><![CDATA[目录 什么是单元测试 Jest &amp;&amp; Enzyme 测试实战 总结 什么是单元测试单元测试 维基百科 在计算机编程中，单元测试（英语：Unit Testing）又称为模块测试, 是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。通常来说，程序员每修改一次程序就会进行最少一次单元测试，在编写程序的过程中前后很可能要进行多次单元测试，以证实程序达到软件规格书要求的工作目标，没有程序错误；虽然单元测试不是什么必须的，但也不坏，这牵涉到项目管理的政策决定。每个理想的测试案例独立于其它案例；为测试时隔离模块，经常使用stubs、mock或fake等测试马甲程序。单元测试通常由软件开发人员编写，用于确保他们所写的代码匹配软件需求和遵循开发目标。它的实施方式可以是非常手动的（透过纸笔），或者是做成构建自动化的一部分。 一个软件越容易写单元测试，就表明它的模块化结构越好，模块之间的耦合越弱。React的组件化和函数式编程，天生适合进行单元测试。 为什么要写单元测试 测试可以确保得到预期的结果，改代码更自信 有单元测试的代码，通常是更好的代码 写单元测试的时候，会更深入的认识代码； 为了更方便的写单元测试，组件拆分更合理。 所有代码变动都是可预期的 更好的提升自我 写单测的开发更靠谱 更好的吹牛逼（我的单元测试覆盖率是100%） 评级加分 单元测试不是万能的 单元测试只是测试代码功能，不包含复杂的业务逻辑。 Jest &amp;&amp; EnzymeJestJest是Facebook发布的一个开源的、基于Jasmine框架的JavaScript单元测试工具。提供了包括内置的测试环境DOM API支持、断言库、Mock库等，还包含了Spapshot Testing、 Instant Feedback等特性。用来测试包括React应用在内的所有JavaScript代码。 优点 提供控制台实时反馈测试结果 提供内置的测试环境DOM API支持、断言库、Mock库、代码覆盖率报告 Snapshot测试：Jest能够对React组件树进行序列化，生成对应的字符串快照，通过比较字符串提供高性能的UI检测 执行速度快 无需配置 使用 create-react-app 或 react-native init 创建你的 React 或 React Native 项目时，Jest 都已经被配置好并可以使用了。在 tests文件夹下放置你的测试用例，或者使用 .spec.js 或 .test.js 后缀给它们命名。不管你选哪一种方式，Jest 都能找到并且运行它们。 丰富的api，完善的文档 在线使用 可以使用repl.it来在线尝试Jest。想想怎么用add ()函数来相加两个数。我们可以编写一个简单的测试，通过 add-test.js来验证 1 + 2 等于 3。输入”run”立马尝试。 EnzymeEnzyme是Airbnb开源的React测试类库，提供了一套简洁强大的API，并通过jquery风格的方式进行dom处理，开发体验十分友好。不仅在开源社区有超高人气，同时也获得了React官方的推荐。 为啥除了Enzyme又要配合Jest呢？ 因为要编写测试用例的话，光有测试类库还不够，还需要测试运行环境、断言库、mock库等等工具辅以支持；Jest把这些统统囊括。 测试环境搭建以create-react-app为例 1npm install --save enzyme enzyme-adapter-react-16 enzyme-to-json react-test-renderer 如果React的版本是15或者16, Enzyme需要一个Adapter与React通信。adapter需要全局配置，方法如下: 12345src/setupTests.jsimport &#123; configure &#125; from 'enzyme'import Adapter from 'enzyme-adapter-react-16'configure(&#123; adapter: new Adapter() &#125;) 常用api介绍Enzyme api shallow渲染 shallow: 返回App的浅渲染 浅渲染指的是，将一个组件渲染成虚拟DOM对象，但是只渲染第一层，不渲染所有子组件，所以处理速度非常快。它不需要DOM环境，因为根本没有加载进DOM。 find(selector): 返回指定ShallowWrapper组件 123456789component.find('.my-class'); // by class namecomponent.find('#my-id'); // by idcomponent.find('td'); // by tagcomponent.find('div.custom-class'); // by compound selectorcomponent.find('[bar=false]'); // by prop selectorcomponent.find(TableRow); // by react component constructorcomponent.find('TableRow'); // by react component's displayname at(index): 返回指定位置的子组件 get(index): 返回指定位置的子组件的DOM节点 props(): 返回根组件的所有属性 prop(key): 返回根组件的指定属性 state([key]): 返回根组件的状态 setState(nextState): 设置根组件的状态 setProps(nextProps): 设置根组件的属性 simulate(event[, …args]): 模拟事件 debug() 1console.log(wrapper.find('Ueditor').debug()) 它跟shallow方法非常像，主要的不同是采用了第三方HTML解析库Cheerio，它返回的是一个Cheerio实例对象。 render渲染 render: 将React组件渲染成静态的HTML字符串，然后使用Cheerio这个库分析这段HTML代码的结构，返回一个Cheerio对象。 mount渲染 mount: 完全渲染 将React组件加载为真实DOM节点，用到了jsdom来模拟浏览器环境。用于测试： - 需要跟dom api交互的组件 - 被高阶组件包装的组件 Jest api globals api describe(name, fn)：描述块，讲一组功能相关的测试用例组合在一起，test suite it(name, fn, timeout)：别名test，用来放测试用例，test case afterAll(fn, timeout)：所有测试用例跑完以后执行的方法 beforeAll(fn, timeout)：所有测试用例执行之前执行的方法 afterEach(fn)：在每个测试用例执行完后执行的方法 beforeEach(fn)：在每个测试用例执行之前需要执行的方法 expect api expect.toMatchSnapshot() expect.toBeCalledWith(arg1, arg2, …) expect.toEqual(value) expect.toBe(value)，相当于=== mock api jest.fn(): mock function jest.fn().mockResolvedValue(value): 异步mock promise的resolve jest.fn().mockRejectedValue(new Error(‘Async error’)): 异步mock promise的reject Jest命令行 运行所有测试(默认) 1jest or 1npm test 运行监视模式 12npm test --watch // 默认运行基于 hg/git (未提交的文件) 修改的文件的测试npm test --watchAll 生成测试覆盖率报告 1npm test --coverage 测试脚本编写1234567891011import React from 'react'import &#123;shallow&#125; from 'enzyme'import toJson from 'enzyme-to-json'import App from './App'describe('App', () =&gt; &#123; // test suite it('test default props', () =&gt; &#123; // test case const wrapper = shallow(&lt;App /&gt;) expect(toJson(wrapper)).toMatchSnapshot() &#125;)&#125;) snapshot引入’enzyme-to-json’，使用toJson方法，快照会生成一个组件的UI结构。jest在执行的时候，如果发现toMatchSnapshot方法，会在同级目录下生成一个snapshots文件夹,以字符串的形式存放快照文件。 以后每次测试的时候都会和第一次生成的快照进行字符串比较来判断UI是否改变。因为是字符串比较，所以性能很高。 1234567891011121314151617181920212223242526272829303132// 上文中代码生成的snapshotexports[`App test default props 1`] = `&lt;div className="App"&gt; &lt;header className="App-header" &gt; &lt;img alt="logo" className="App-logo" src="logo.svg" /&gt; &lt;p&gt; Edit &lt;code&gt; src/App.js &lt;/code&gt; and save to reload. &lt;/p&gt; &lt;a className="App-link" href="https://reactjs.org" rel="noopener noreferrer" target="_blank" &gt; Learn React &lt;/a&gt; &lt;/header&gt;&lt;/div&gt;`; 当两次快照内容不同时，可以手动修复问题解决。如果是你期望的改动，则可以直接使jest –updateSnapshot来更新快照文件。也可以在监视模式下直接按’u’来更新快照。 优点 不用写大量的断言判断ui，自动生成 异常时给出详细的错误信息，方便调试 一键更新，无需重写测试用例 万物皆可snapshot snapshot不是万能的 snapshot不能覆盖100% snapshot不能替代其他单元测试方法 测试实战what:测什么 测试优先级 独立不依赖，常用组件 辅助性组件，utils 更复杂组件 不需要测试 第三方库 常量 内联样式(不会改变组件的行为) 高阶组件(HOC) how:怎么测示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Choice extends PureComponent &#123; renderType = (type, index) =&gt; &#123; const &#123; answer &#125; = this.props const value = String.fromCharCode(index + 65) switch (type) &#123; case 'checkbox': return ( &lt;Checkbox value=&#123;value&#125; checked=&#123;answer &amp;&amp; answer.includes(value)&#125; &gt; 选项&#123;value&#125;： &lt;/Checkbox&gt; ) case 'radio': return &lt;Radio value=&#123;value&#125; checked=&#123;value === answer&#125;&gt;选项&#123;value&#125;：&lt;/Radio&gt; default: return `选项$&#123;value&#125;：` &#125; &#125; render() &#123; const &#123; choice, index, type, onChange, onClick, parentIndex &#125; = this.props return ( &lt;div className=&#123;s.choice&#125; &gt; &lt;header&gt; &#123; this.renderType(type, index) &#125; &lt;/header&gt; &lt;Row type="flex" justify="start"&gt; &lt;Col&gt; &lt;Button icon="delete" onClick=&#123;() =&gt; onClick(index, parentIndex)&#125; /&gt; &lt;/Col&gt; &lt;/Row&gt; &lt;/div&gt; ) &#125;&#125;Choice.propTypes = &#123; choice: PropTypes.string.isRequired, index: PropTypes.number.isRequired, onChange: PropTypes.func.isRequired, onClick: PropTypes.func.isRequired, answer: PropTypes.string, type: PropTypes.string, parentIndex: PropTypes.number, &#125;Choice.defaultProps = &#123; type: 'text', answer: '', parentIndex: null,&#125;export default Choice ui测试 snapshot测试 prop测试 带prop参数的snapshot测试 123456789101112131415161718192021222324252627282930313233343536373839it('default props', () =&gt; &#123; const wrapper = shallow( &lt;Choice choice="A" index=&#123;0&#125; onChange=&#123;() =&gt; null&#125; onClick=&#123;() =&gt; null&#125; /&gt; ) expect(toJson(wrapper)).toMatchSnapshot()&#125;)it('test props type=radio', () =&gt; &#123; const wrapper = shallow( &lt;Choice choice="A" index=&#123;0&#125; onChange=&#123;() =&gt; null&#125; onClick=&#123;() =&gt; null&#125; type="radio" answer="A" /&gt; ) expect(toJson(wrapper)).toMatchSnapshot()&#125;)it('test props type=checkbox', () =&gt; &#123; const wrapper = shallow( &lt;Choice choice="A" index=&#123;0&#125; onChange=&#123;() =&gt; null&#125; onClick=&#123;() =&gt; null&#125; type="checkbox" answer="AB" /&gt; ) expect(toJson(wrapper)).toMatchSnapshot()&#125;) event测试 对于事件，按照如下思路测试： 123mock event =&gt; simulate it =&gt; expect event was calledmock event =&gt; simulate event with params =&gt; expect event was called with passed paramspass necessary props =&gt; render component =&gt; simulate event =&gt; expect a certain behavior on called event 比如： 123456789101112131415161718it('test function onClick', () =&gt; &#123; const choice = 'C' const index = 2 const parentIndex = 0 const onClick = jest.fn() const wrapper = shallow( &lt;Choice choice=&#123;choice&#125; index=&#123;index&#125; parentIndex=&#123;parentIndex&#125; onChange=&#123;() =&gt; null&#125; onClick=&#123;onClick&#125; answer="A" /&gt; ) wrapper.find('Button').at(0).simulate('click', index, parentIndex) expect(onClick).toBeCalledWith(index, parentIndex)&#125;) 如果事件中有event参数，比如: 123456789handleDifficulty(e) &#123; this.handleChange(&#123; difficulty: e.target.value &#125;)&#125;// 单测中要用&#123; target: &#123; value &#125; &#125;it('test function handleDifficulty', () =&gt; &#123; const value = 1 wrapper.find('RadioGroup').at(0).simulate('change', &#123; target: &#123; value &#125; &#125;) expect(onChange).toBeCalledWith(&#123; difficulty: value &#125;)&#125;) ==备注：对于组件自定义事件，尽量以onXXX命名，才能在simulate的时候触发== state测试 123456789101112131415161718it('test function onClick', () =&gt; &#123; const choice = 'C' const index = 2 const parentIndex = 0 const onClick = jest.fn() const wrapper = shallow( &lt;Choice choice=&#123;choice&#125; index=&#123;index&#125; parentIndex=&#123;parentIndex&#125; onChange=&#123;() =&gt; null&#125; onClick=&#123;onClick&#125; answer="A" /&gt; ) wrapper.find('Button').at(0).simulate('click', index, parentIndex) expect(wrapper.state('videoList')).toEqual(null)&#125;) 代码覆盖率代码覆盖率是一个测试指标，用来描述测试用例的代码是否都被执行。统计代码覆盖率一般要借助代码覆盖工具，Jest内置代码覆盖工具。 四个测量维度 行覆盖率(line coverage)：是否测试用例的每一行都执行了 函数覆盖率(function coverage)：是否测试用例的每一个函数都调用了 分支覆盖率(branch coverage)：是否测试用例的每个if代码块都执行了 语句覆盖率(statement coverage)：是否测试用例的每个语句都执行了 antd-pro 中遇到的问题 jest报错： 1SecurityError: localStorage is not available for opaque origins https://github.com/facebook/jest/issues/6769 解决方案： 下载了一个最新版的antd-pro 2.0，居然解决了，😠生气 就是在目录下加了一个jest.config.js文件，里面的内容是： 123module.exports = &#123; testURL: 'http://localhost:8000',&#125; 获取Panel header中的组件 1console.log(shallow(wrapper.find('CollapsePanel').prop('header')).debug()) antd组件必须这么引用，否则jest会报错 const Panel = Collapse.Panel upload的beforeupload方法无法模拟触发 123456&lt;Upload fileList=&#123;audioList&#125; disabled=&#123;audioList &amp;&amp; audioList.length &gt; 0&#125; beforeUpload=&#123;this.handleBeforeUpload&#125; onRemove=&#123;this.handleFileRemove&#125;/&gt; expect随机数 123456789101112131415161718192021it('will check the matchers and pass', () =&gt; &#123; const user = &#123; createdAt: new Date(), id: Math.floor(Math.random() * 20), name: 'LeBron James', &#125; expect(user).toMatchSnapshot(&#123; createdAt: expect.any(Date), id: expect.any(Number), &#125;)&#125;)// Snapshotexports[`will check the matchers and pass 1`] = `Object &#123; "createdAt": Any&lt;Date&gt;, "id": Any&lt;Number&gt;, "name": "LeBron James",&#125;` or 1Date = jest.fn(() =&gt; 1482363367071) HOC connect(container) antd pro推荐这种做法： 被 dva connect 的 React 组件可以使用下面方式进行测试。 1234567891011import React from 'react'import &#123; shallow &#125; from 'enzyme'import Dashboard from './Dashboard'it('renders Dashboard', () =&gt; &#123; // 使用包装后的组件 const wrapper = shallow( &lt;Dashboard.WrappedComponent user=&#123;&#123; list: [] &#125;&#125; /&gt; ) expect(wrapper.find('Table').props().dataSource).toEqual([])&#125;) 关于Component.WrappedComponent The wrapped component is exposed as the static property WrappedComponent on the returned component, which can be used for testing the component in isolation, among other things. 123456// MyComponent.jsexport default withRouter(MyComponent)// MyComponent.test.jsimport MyComponent from './MyComponent'render(&lt;MyComponent.WrappedComponent location=&#123;&#123;...&#125;&#125; ... /&gt;) HOC withRouter(container) redux官方推荐这种做法： 1234567import &#123; connect &#125; from 'react-redux'​// Use named export for unconnected component (for tests)export class App extends Component &#123; /* ... */ &#125;​// Use default export for the connected component (for app)export default connect(mapStateToProps)(App) mock dispatch 1const dispatch = jest.fn().mockResolvedValue('default') 总结 Jest + Enzyme 写单元测试快速方便 Snapshot简单易用，在不追求测试覆盖率的情况下，可以简单写几个snapshot 单元测试对于写更好的代码，很有帮助 参考文献 https://zh.wikipedia.org/wiki/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95 https://jestjs.io/docs/zh-Hans/getting-started.html https://airbnb.io/enzyme/ http://react-china.org/t/jest-enzyme-react/11769 https://github.com/facebook/create-react-app/blob/master/packages/react-scripts/template/README.md#initializing-test-environment https://www.youtube.com/watch?v=8Ww2QBVIw0I&amp;feature=youtu.be https://github.com/ned-alyona/posts/tree/master/jest-enzyme-testing https://juejin.im/post/5b6c39bde51d45195c079d62 http://echizen.github.io/tech/2017/04-24-component-lifycycle-test https://medium.com/@newyork.anthonyng/use-jest-snapshot-on-everything-4c5d4c88ca16 https://hackernoon.com/snapshot-testing-react-components-with-jest-744a1e980366 https://blog.bitsrc.io/how-to-test-react-components-using-jest-and-enzyme-fab851a43875 https://pro.ant.design/docs/ui-test-cn https://cn.redux.js.org/docs/recipes/WritingTests.html https://hackernoon.com/testing-react-components-with-jest-and-enzyme-41d592c174f https://github.com/r-walsh/react-unit-test-practice]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>React</tag>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac高效开发小技巧]]></title>
    <url>%2F%2Fblog%2F2018%2F09%2FMac%E9%AB%98%E6%95%88%E5%BC%80%E5%8F%91.html</url>
    <content type="text"><![CDATA[ssh别名用户名、IP 地址和端口号还是不想记忆，此时可以利用 SSH 的配置文件来实现。 编辑 ~/.ssh/config 文件，添加以下内容： 12345Host testhost HostName 1.2.3.4 User root Port 54321 IdentityFile ~/.ssh/id_rsa 这个配置文件还是很容易理解的，我们给地址为 1.2.3.4，端口为 54321，用户名为 root 的远程主机起了一个别名，然后就可以这样连接了： 1ssh testhost 再也不用担心自己记不住那么多远程主机 vim操作行和屏幕移动Vim 的翻页快捷键是： 1234Ctrl + f：向后翻一页（forward）Ctrl + b：向前翻一页（backward）Ctrl + d：向后翻半页（down）Ctrl + u：向前翻半页（up） 文本编辑 在普通模式下，按下 o会快速进入输入模式，并且在下一行进行编辑 按下大写的O会在上一行编辑 I 前往行头开始编辑 A 跳转到行尾编辑 撤销与重做 撤销上一次修改，可以用 u，类似于系统的 Command + z 快捷键 重做，可以用 Ctrl + R，类似于系统的 Command + Shift + z 快捷键]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>macbook</tag>
        <tag>ssh</tag>
        <tag>vi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[literallycanvas的简介]]></title>
    <url>%2F%2Fblog%2F2018%2F08%2Fliterallycanvas%E7%AE%80%E4%BB%8B.html</url>
    <content type="text"><![CDATA[git项目目录： _static literallycanvas的依赖文件 classic_style 用普通js的方式编写的用例 react_style 基于create-react-app编写的用例 freecanvas-demo 二次开发，基本实现了图片旋转功能 xmind api介绍 LiterallyCanvas是什么Literally Canvas是一个可扩展的开源（BSD许可）HTML5绘图组件，可以用于网页中插入画图板，类似于windows自带的画图板。可以用可视化工具绘制图画，同时提供api完成相同的功能，也可以将结果导出。它依赖于React.js，所以很方便在react项目中使用。 特性 基本的绘画工具 编码自定义绘画工具 平移和缩放 背景图、水印 支持Retina 保存和加载 JSON 输出图片到PNG或SVG 丰富的API 无缝接入React 开源 快速上手 加载literallycanvas 普通方式 123456789101112131415161718192021&lt;html&gt;&lt;head&gt; &lt;!-- 需要react --&gt; &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.14.7/react-with-addons.js"&gt;&lt;/script&gt; &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.14.7/react-dom.js"&gt;&lt;/script&gt; &lt;!-- literallycanvas的js文件 --&gt; &lt;script src="../_static/js/literallycanvas.js"&gt;&lt;/script&gt; &lt;!-- literallycanvas的css文件 --&gt; &lt;link href="../_static/css/literallycanvas.css" rel="stylesheet"&gt; &lt;title&gt;literallycanvas-with-gui&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="my-drawing"&gt;&lt;/div&gt; &lt;script&gt; LC.init( document.getElementsByClassName('my-drawing')[0], &#123; imageURLPrefix: '../_static/img'&#125; ); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; react方式 12345678910111213import React, &#123; PureComponent &#125; from 'react'import &#123; LiterallyCanvasReactComponent &#125; from 'literallycanvas'import 'literallycanvas/lib/css/literallycanvas.css'export default class Exmaple1 extends PureComponent &#123; render() &#123; return ( &lt;div className="App"&gt; &lt;LiterallyCanvasReactComponent imageURLPrefix="static/img" /&gt; &lt;/div&gt; ) &#125;&#125; package.json1234567891011121314151617181920&#123; "name": "react_style_literally", "version": "0.1.0", "private": true, "description": "目前版本0.4.13不支持react16以上，v5.0以上支持", "dependencies": &#123; "react": "^15.6.0", "react-dom": "^15.6.0", "react-scripts": "1.1.4", "react-router-dom": "^4.3.1", "literallycanvas": "0.4.13" &#125;, "scripts": &#123; "start": "react-scripts start", "build": "react-scripts build", "test": "react-scripts test --env=jsdom", "eject": "react-scripts eject" &#125;&#125; (!!!官网方式不靠谱)12345678910111213141516171819202122232425&lt;html&gt; &lt;head&gt; &lt;!-- stylesheet --&gt; &lt;link href="/static/css/literallycanvas.css" rel="stylesheet"&gt; &lt;!-- dependency: React.js --&gt; &lt;script src="//cdnjs.cloudflare.com/ajax/libs/react/0.14.7/react-with-addons.js"&gt;&lt;/script&gt; &lt;script src="//cdnjs.cloudflare.com/ajax/libs/react/0.14.7/react-dom.js"&gt;&lt;/script&gt; &lt;script src="//cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js"&gt;&lt;/script&gt; &lt;!-- Literally Canvas --&gt; &lt;script src="/static/js/literallycanvas.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="root"&gt;&lt;/div&gt; &lt;script type="text/babel"&gt; ReactDOM.render( &lt;div&gt; &lt;LC.LiterallyCanvasReactComponent imageURLPrefix="/static/img" /&gt; &lt;/div&gt;, document.getElementById('root')); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 修改样式（修改画图板的宽高） 宽度，可以通过修改父组件宽度来修改 高度，原有样式为min-hight:400px,修改父组件不好使1234567891011.my-drawing &#123; /* 宽度可自定义 */ width: 1000px; /* 高度无效 */ height: 600px;&#125;/* 覆盖literally样式 */.my-drawing .literally &#123; height: 600px;&#125; 原理 两个canvas叠加，一个负责渲染背景内容，一个负责渲染涂画操作 API init shapes snapshot … 示例代码 二次开发 下载源码 git clone https://github.com/literallycanvas/literallycanvas.git 源码目录 基于coffee-script开发（看不懂的，可以选择读lib目录下的js） 打包 执行gulp命令生成新的lib/js/literallycanvas.js 如果是基于react的修改，怎么办？ 本地修改保持不变 自己打一个npm包 给该项目发起Pull Request 总结 优点： 比其他开源画图工具功能更加强大，其他的只提供基本的图片展示、画笔、橡皮擦功能 无缝接入react项目 开源 可扩展，使用API 速度快github上满足批改后台需求的最合适项目 缺点： 更新缓慢 配置文件不够细，不能满足某些需求 功能不满足：1）图片旋转(如有需要，可使用freecanvas这个npm包，这是我基于literallycanvas开发的，增加了图片旋转功能)2）文字添加后可移动位置]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>知识点</tag>
        <tag>Literallycanvas</tag>
        <tag>React</tag>
      </tags>
  </entry>
</search>
